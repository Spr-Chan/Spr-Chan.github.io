<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Java】超严谨论证：为什么自定义类对象存储到Set集合中，要重写hashCode方法和equals方法]]></title>
    <url>%2F20190821-override-hashcode-and-equals.html</url>
    <content type="text"><![CDATA[前言首先看一下Set集合在存储元素的时候，判断元素是否重复的方法： add方法首先调用元素的hashCode方法获取该元素的哈希值，再判断Set集合中有没有元素的哈希值与之重复。如果没有，就会把新的元素存储到数组中。 如果有重复的哈希值（哈希冲突），再调用元素的equals方法和Set中已有的哈希值相同的元素进行比较：如果equals方法返回true，认定两个元素相同，就不会把新元素存储到集合中；如果equals方法返回false，则认定两个元素内容不同，就会把新元素存储到集合中，放在同一个哈希值下形成链表。 那么如果一个自定义类对象不重写hashCode方法和equals方法就add到Set集合中，会发生什么情况？ &emsp;&emsp;PS：论证之前需理解“哈希冲突”的概念，可参考我之前写的一篇文章。简单地说就是字符串“重地”和“通话”的哈希值是相同的。 论证&emsp;&emsp;假设有两个不同的自定义类对象p1、p2： 自定义类没有重写hashCode方法：&emsp;&emsp;• p1、p2存储的数据相同，p1、p2哈希值不同（这时不再调用对象的equals方法），两者都能存储到Set集合中（不合理，Set集合元素不能重复）。&emsp;&emsp;&emsp;&emsp;注：1. 如果自定义类没有重写hashCode方法，无论p1、p2存储的数据相同或不相同（或者是”重地”和”通话”的情况），p1、p2的哈希值都不同。2. Set集合的add方法直接通过调用元素的hashCode方法就已经判断出p1、p2都能存储到集合中，就不再调用对象的equals方法了，所以重不重写equals方法对结果无影响。&emsp;&emsp;• p1、p2存储的数据不同，p1、p2哈希值不同（这时不再调用对象的equals方法），两者都能存储到Set集合中（合理）。 自定义类重写了hashCode方法，但没有重写equals方法：&emsp;&emsp;• p1、p2存储的数据相同，p1、p2哈希值相同，但是因为p1、p2的“物理”地址值不同，所以p1.equals(p2)返回false，两者任都能存储到Set集合中（不合理）。&emsp;&emsp;&emsp;&emsp;注：1. IDEA默认的重写hashCode方法的返回值是根据类的每一个成员变量的哈希值综合生成的，所以不同对象若存储的数据相同，则哈希值一定相同。2. 没有重写equals方法的话，equals比较的就是真实“物理”地址值 ！3. 不同对象的真实“物理”地址值一定是不同的（一定是存放在内存中的不同地址）。&emsp;&emsp;• p1、p2存储的数据不同，哈希值不同（这时不再调用对象的equals方法），两者都能存储到Set集合中（合理）。&emsp;&emsp;&emsp;&emsp;注：极少情况下p1、p2存储的数据不同但哈希值相同（如”重地”和”通话”），这时调用对象的equals方法，因为没有重写equals方法，所以p1.equals(p2)返回false，所以p1、p2任都能存储到Set集合中（合理）。 自定义类重写了hashCode方法和equals方法&emsp;&emsp;• p1、p2存储的数据相同，p1、p2的哈希值相同，p1.equals(p2)返回true，两者都不能存储到Set集合中（合理）。&emsp;&emsp;&emsp;&emsp;注：重写自定义类的equals方法，p1.equals(p2)比较的是对象的内容。&emsp;&emsp;• p1、p2存储的数据不同，p1、p2的哈希值不同（这时不再调用对象的equals方法），两者都能存储到Set集合中（合理）。&emsp;&emsp;&emsp;&emsp;注：极少情况下p1、p2存储的数据不同但哈希值相同（如”重地”和”通话”），这时调用对象的equals方法，因为equals方法已重写，所以p1.equals(p2)返回false，两者都能存储到Set集合中（合理）。 &emsp;&emsp;可以看到，第三点在任意情况下的结果都是“合理”，这就是为什么自定义类对象存储到Set集合中，要重写hashCode方法和equals方法。&emsp;&emsp;&emsp;&emsp;注：1. 不管自定义类有没有重写hashCode方法和equals方法，p1 == p2返回的都是false，因为对象之间的”==”比较的是对象的“物理”地址值，不是哈希值或内容，两个不同对象的物理地址值一定不同（无论对象存储的数据是否相等，或是”重地”和”通话”的情况）。2. 重写hashCode方法和equals方法很简单，IDE中快捷键ALT+Ins-&gt;equals( ) and hashCode( )。 相关文章推荐&emsp;&emsp;【Java】哈希值相同的变量/对象的地址值也相同吗？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashCode</tag>
        <tag>Set</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】哈希值相同的变量_对象的地址值也相同吗？]]></title>
    <url>%2F20190821-same-hashcode.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;“Java中直接打印对象，输出的是对象的地址值（对象的类没有重写toString方法）”，这是初学者在学Java基础语言的时候，大多数教程都是这么介绍的，初学者也会认为这就是对象在内存中存储的位置，如输出的地址值为： 1cn.imcyc.person.Person@11ff03 但是，其实这种说法是有混淆性的，实际上，打印对象输出的“地址值”并不是对象的物理存储地址，@之后的“11ff03”只是这个对象的哈希值的十六进制。 &emsp;&emsp;实际上，Java语言中其实是看不到变量/对象真正的物理地址值的，只能通过hashCode方法查到变量/对象的哈希值，在极少数的情况下，变量/对象的哈希值会重复，也就是“哈希碰撞”、“哈希混淆”现象。如果初学者看到两个不同数据的类型/对象打印出的“包名.类名@十六进制哈希值”是一样的，就会误以为这两个类型/对象的地址值是相同的，这种想法是错误的。 &emsp;&emsp;下面介绍一种“哈希冲突”的情况。 哈希值相同的String类对象1234String a = "重地";String b = "通话";System.out.println(a.hashCode());System.out.println(b.hashCode()); 上面代码的执行结果是： 1211793951179395 字符串类对象a和b的哈希值是相同的，但事实上两者的物理存储地址是不同的。那么如果将“重地”和“通话”作为字符串存储到对象中，对象的哈希值会一样吗？ 哈希值相同的自定义类对象&emsp;&emsp;新建一个Person类，有一个私有字符串数据成员，两个构造函数，如下： 1234567891011public class Person &#123; private String name; public Person() &#123; &#125; public Person(String name) &#123; this.name = name; &#125;&#125; &emsp;&emsp;主程序执行如下代码： 123456Person c = new Person("重地");Person d = new Person("通话");System.out.println(c);System.out.println(c.hashCode());System.out.println(d);System.out.println(d.hashCode()); 执行结果： 1234cn.imcyc.person.Person@75412c2f1967205423cn.imcyc.person.Person@282ba1e42121758 &emsp;&emsp;可以看到，对象c和d的哈希值不同的。 拓展：重写Person类的hashCode方法&emsp;&emsp;重写了hashCode方法的Person类代码为： 123456789101112131415public class Person &#123; private String name; @Override public int hashCode() &#123; return name != null ? name.hashCode() : 0; &#125; public Person() &#123; &#125; public Person(String name) &#123; this.name = name; &#125;&#125; 上面重写的hashCode的方法是IDEA默认生成的，可以看到就是把数据成员name的哈希值拿来当对象的哈希值，再次执行主程序的代码，输出为： 1234cn.imcyc.person.Person@11ff031179395cn.imcyc.person.Person@11ff031179395 可以看到这时的c和d两个对象的哈希值就相同了，但是能说对象c和对象d的地址值相同吗？显然是不能的，对象c和对象d的物理存储地址一定是不同的。 相关文章推荐&emsp;&emsp;【Java】超严谨论证：为什么自定义类对象存储到Set集合中，要重写hashCode方法和equals方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JDBC】使用_不使用数据库连接池获取连接对比]]></title>
    <url>%2F20190817-jdbc-druid.html</url>
    <content type="text"><![CDATA[不使用数据库连接池 不使用工具类获取连接（以及注册驱动）: 1234//注册驱动Class.forName("com.mysql.jdbc.Driver");//把要注册的驱动加载进内存//获取数据库连接对象Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "4719"); 使用工具类、配置文件获取连接（以及注册驱动）: 1con=JDBCUtils.getconnection(); &emsp;&emsp;&emsp;&emsp;工具类代码（加载配置文件、注册驱动、获取连接部分）: 123456789101112131415161718192021222324252627282930313233343536373839private static String url;private static String user;private static String password;private static String driver;/** * 静态代码块：随着类的加载而加载，只执行一次。用来读取配置文件的信息，并注册驱动 */static &#123; try &#123; //创建Properties集合类对象 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;classLoader类加载器 //classLoader可以加载字节码文件进内存，并且可以获取资源路径 //通过类JDBCUtils获得JDBCUtils的类加载器，再通过getResource获得配置文件的资源路径（非配置文件存储路径） String path = JDBCUtils.class.getClassLoader().getResource("jdbc.properties").getPath(); //加载配置文件 pro.load(new FileReader(path)); //获取数据，并赋值 url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); //注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;/** * 获取连接 * @return 连接对象 */public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password);&#125; &emsp;&emsp;&emsp;&emsp;配置文件： 1234url=jdbc:mysql:///db3user=rootpassword=4719driver=com.mysql.jdbc.Driver 使用数据库连接池 不使用工具类获取连接（注册驱动步骤隐藏）: 12345678910//1.导入jar包//2.定义配置文件//3.加载配置文件Properties pro = new Properties();InputStream is = DruidDemo01.class.getClassLoader().getResourceAsStream("druid.properties");pro.load(is);//4.获取连接池对象DataSource ds = DruidDataSourceFactory.createDataSource(pro);//5.获取连接Connection conn = ds.getConnection(); 使用工具类、配置文件获取连接（注册驱动步骤隐藏： 1conn = JDBCUtils.getconnection(); &emsp;&emsp;&emsp;&emsp;工具类代码（加载配置文件、获取连接部分）： 12345678910111213141516171819202122//1.定义成员变量 DataSourceprivate static DataSource ds;//静态代码块：加载配置文件，初始化连接池对象static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;//获取连接public static Connection getConnection() throws SQLException &#123; return ds.getConnection();&#125; &emsp;&emsp;&emsp;&emsp;配置文件： 12345678910driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/db3username=rootpassword=4719# 初始化连接数量initialSize=5# 最大连接数maxActive=10#最大等待时间maxWait=3000 总结对比使用数据库连接池的缺点： 每次都需要向操作系统底层申请连接，用完再释放，效率低下。 配置文件的数据要手动获取，再用DriverManager.getConnection（）获取连接，代码复杂。 使用数据库连接池的优点： 数据池获取连接，节约资源，用户访问高效。 自动读取配置文件的数据，获取连接，代码简洁。 画图板整理原件 相关文章推荐&emsp;&emsp;【JDBC练习】使用用户名和密码登录&emsp;&emsp;【JDBC练习】查看表的方法——表的数据封装成对象并装载成集合]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MYSQL</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JDBC练习】使用用户名和密码登录]]></title>
    <url>%2F20190815-jdbc-login.html</url>
    <content type="text"><![CDATA[前言需求：&emsp;&emsp;1. 通过键盘录入用户名和密码&emsp;&emsp;2. 判断用户是否登录成功 分析：&emsp;&emsp;使用sql语句：select * from user where username = “ “ and password = “ “，如果这个sql有查询结果，则成功；反之，则失败。 步骤 首先创建数据库表user，添加两个用户名及密码作为已注册用户。1234567CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT,-- id 主键 自增长 username VARCHAR(32), PASSWORD VARCHAR(32));INSERT INTO USER VALUES(NULL, 'zhangsan', '123');INSERT INTO USER VALUES(NULL, '1isi', '234'); 使用SQLyog查看表，如下图所示。 创建配置文件，增加程序拓展性 1234url=jdbc:mysql:///db4user=rootpassword=4719driver=com.mysql.jdbc.Driver 创建工具类JDBCUtils，简化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package cn.imcyc.util;import java.io.FileReader;import java.io.IOException;import java.sql.*;import java.util.Properties;/** * JDBC工具类 */public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 静态代码块：随着类的加载而加载，只执行一次。用来读取配置文件的信息 */ static &#123; try &#123; //创建Properties集合类对象 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;classLoader类加载器 //classLoader可以加载字节码文件进内存，并且可以获取资源路径 //通过类JDBCUtils获得JDBCUtils的类加载器，再通过getResource获得配置文件的资源路径（非配置文件存储路径） String path = JDBCUtils.class.getClassLoader().getResource("jdbc.properties").getPath(); //System.out.println(path); //加载配置文件 pro.load(new FileReader(path)); //获取数据，并赋值 url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); //注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt, Connection conn)&#123; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 创建JdbcDemo06，代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.imcyc.jdbc;import cn.imcyc.util.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;/** * 需求： * 1.通过键盘录入用户名和密码 * 2.判断用户是否登录成功 */public class JdbcDemo06 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println("请输入用户名："); String username = sc.nextLine(); System.out.println("请输入密码："); String password = sc.nextLine(); //2.调用方法 boolean flag = new JdbcDemo06().login(username, password); //3.判断结果，输出不同语句 if (flag) &#123; System.out.println("登录成功！"); &#125; else &#123; System.out.println("用户名或密码错误！"); &#125; &#125; /** * 登录方法 */ public boolean login(String username, String password) &#123; if (username == null || password == null) &#123; return false; &#125; //连接数据库判断登录是否成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; //使用工具类注册驱动、获取链接 conn = JDBCUtils.getConnection();//把配置文件修改为db4 //定义sql String sql = "select * from user where username = '" + username + "' and password = '" + password + "'"; //获取执行sql的对象 stmt = conn.createStatement(); //执行查询 rs = stmt.executeQuery(sql); //判断 return rs.next();//因为上面的sql语句查询出来的就只有一行数据（或无），所以rs.next()为真则代表有下一行，即查询成功 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(rs, stmt, conn); &#125; return false; &#125;&#125; 执行JdbcDemo06，输入用户名和密码验证登录是否成功，效果如下图。 安全性问题（SQL注入问题）&emsp;&emsp;SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题。例如输入任意用户名，输入密码：a’ or ‘a’ = ‘a，使得sql语句变成 1select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 就能登陆成功，这显然是非常严重的安全问题。 &emsp;&emsp;解决SQL注入问题：使用Preparedstatement对象来解决，将上面主程序代码修改为（或创建一个新Demo）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.imcyc.jdbc;import cn.imcyc.util.JDBCUtils;import java.sql.*;import java.util.Scanner;public class JdbcDemo07 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println("请输入用户名："); String username = sc.nextLine(); System.out.println("请输入密码："); String password = sc.nextLine(); //2.调用方法 boolean flag = new JdbcDemo07().login(username, password); //3.判断结果，输出不同语句 if (flag) &#123; System.out.println("登录成功！"); &#125; else &#123; System.out.println("用户名或密码错误！"); &#125; &#125; /** * 登录方法，使用PreparedStatement实现 */ public boolean login(String username, String password) &#123; if (username == null || password == null) &#123; return false; &#125; //连接数据库判断登录是否成功 Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; //使用工具类注册驱动、获取链接 conn = JDBCUtils.getConnection();//把配置文件修改为db4 //定义sql String sql = "select * from user where username = ? and password = ?"; //获取执行sql的对象 pstmt = conn.prepareStatement(sql); //给 ? 赋值 pstmt.setString(1,username); pstmt.setString(2,password); //执行查询（不需要传递sql） rs = pstmt.executeQuery(); //判断 return rs.next();//因为上面的sql语句查询出来的就只有一行数据（或无），所以rs.next()为真则代表有下一行，即查询成功 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(rs, pstmt, conn); &#125; return false; &#125;&#125; 注意： sql的参数使用 ？作为占位符。如：select * from user where username = ? and password = ?; 给 ？赋值：方法：setXxx(参数1, 参数2)参数1：？的位置编号从1开始参数2：？的值 &emsp;&emsp;后期都会使用PreparedStatement来完成增删改查的所有操作，因为：1. 可以防止SQL注入；2. 效率更高。 相关文章推荐&emsp;&emsp;【JDBC练习】查看表的方法——表的数据封装成对象并装载成集合&emsp;&emsp;【JDBC】使用_不使用数据库连接池获取连接对比]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JDBC练习】查看表的方法——表的数据封装成对象并装载成集合]]></title>
    <url>%2F20190814-jdbc-check-table.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在MYSQL的db3数据库中存在表emp，通过可视化软件SQLyog可以方便的查看表的数据，如下图所示。那么如何通过JDBC来查看表？ 教程步骤 首先新建一个Emp类，把emp表的列名当成Emp类的私有数据成员，Emp类的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package cn.imcyc.domain;import java.util.Date;/** * 封装Emp表数据的JavaBean */public class Emp &#123; private int id; private String ename; private int job_id; private int mgr; private Date joindate; private double salary; private double bonus; private int dept_id; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public int getJob_id() &#123; return job_id; &#125; public void setJob_id(int job_id) &#123; this.job_id = job_id; &#125; public int getMgr() &#123; return mgr; &#125; public void setMgr(int mgr) &#123; this.mgr = mgr; &#125; public Date getJoindate() &#123; return joindate; &#125; public void setJoindate(Date joindate) &#123; this.joindate = joindate; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public double getBonus() &#123; return bonus; &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; public int getDept_id() &#123; return dept_id; &#125; public void setDept_id(int dept_id) &#123; this.dept_id = dept_id; &#125; @Override public String toString() &#123; return "Emp&#123;" + "id=" + id + ", ename='" + ename + '\'' + ", job_id=" + job_id + ", mgr=" + mgr + ", joindate=" + joindate + ", salary=" + salary + ", bonus=" + bonus + ", dept_id=" + dept_id + '&#125;'; &#125;&#125; 定义一个方法findAll，用来查询emp表的数据并将其封装成对象，再将对象装载为集合，返回之。最后创建临时无名对象，测试方法findAll，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.imcyc.jdbc;import cn.imcyc.domain.Emp;import java.sql.*;import java.util.ArrayList;import java.util.List;public class JdbcDemo04 &#123; public static void main(String[] args) &#123; /** * 创建临时无名对象，测试方法findAll */ List&lt;Emp&gt; list = new JdbcDemo04().findAll(); for (Emp emp : list) &#123; System.out.println(emp); &#125; //或者 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125; /** * 定义一个方法findAll，用来查询emp表的数据并将其封装成对象，再将对象装载为集合，返回之。 * @return */ public List&lt;Emp&gt; findAll() &#123; ResultSet res = null; Statement stat = null; Connection con = null; List&lt;Emp&gt; list = null; try &#123; //注册驱动、获取链接、定义sql、获取执行sql的对象、执行sql Class.forName("com.mysql.jdbc.Driver"); con = DriverManager.getConnection("jdbc:mysql:///db3", "root", "4719"); String sql = "select * from emp"; stat = con.createStatement(); res = stat.executeQuery(sql); //遍历结果集、封装emp表的数据为对象、装载集合 Emp emp = null; list = new ArrayList&lt;Emp&gt;(); while (res.next()) &#123; //获取数据 int id = res.getInt("id"); String ename = res.getString("ename"); int job_id = res.getInt("job_id"); int mgr = res.getInt("mgr"); Date joindate = res.getDate("joindate"); double salary = res.getDouble("salary"); double bonus = res.getDouble("bonus"); int dept_id = res.getInt("dept_id"); //创建Emp类的对象，并修改对象的数据值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (res != null) &#123; try &#123; res.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return list; &#125;&#125; &emsp;&emsp;查询结果如下：起到跟MYSQL数据库可视化软件SQLyog类似的可视化效果。 &emsp;&emsp;可以看到，主程序的代码过于繁琐（尤其是catch块，重复且繁琐），那么我们可以抽取一个工具类，来简化书写。 抽取工具类简化代码抽取JDBC工具类：&emsp;&emsp;分析：&emsp;&emsp;&emsp;&emsp;1. 抽取注册驱动&emsp;&emsp;&emsp;&emsp;2. 抽取一个方法获取连接对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;需求：不想传递参数（麻烦），还得保证工具类的通用性。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;解决：新建配置文件 jdbc.properties&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;url=&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;user=&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;password=&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;driver=&emsp;&emsp;&emsp;&emsp;3. 抽取一个方法释放资源 步骤&emsp;&emsp;新建配置文件jdbc.properties： 1234url=jdbc:mysql:///db3user=rootpassword=4719driver=com.mysql.jdbc.Driver &emsp;&emsp;新建一个工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package cn.imcyc.util;import java.io.FileReader;import java.io.IOException;import java.sql.*;import java.util.Properties;/** * JDBC工具类 */public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 静态代码块：随着类的加载而加载，只执行一次。用来读取配置文件的信息 */ static &#123; try &#123; //创建Properties集合类对象 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;classLoader类加载器 //classLoader可以加载字节码文件进内存，并且可以获取资源路径 //通过类JDBCUtils获得JDBCUtils的类加载器，再通过getResource获得配置文件的资源路径（非配置文件存储路径） String path = JDBCUtils.class.getClassLoader().getResource("jdbc.properties").getPath(); System.out.println(path); //加载配置文件 pro.load(new FileReader(path)); //获取数据，并赋值 url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); //注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt, Connection conn)&#123; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; &emsp;&emsp;新建JdbcDemo05，把JdbcDemo04的代码复制过来，使用工具类JDBCUtils简化代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.imcyc.jdbc;import cn.imcyc.domain.Emp;import cn.imcyc.util.JDBCUtils;import java.sql.*;import java.util.ArrayList;import java.util.List;public class JdbcDemo05 &#123; public static void main(String[] args) &#123; /** * 创建临时无名对象，测试方法findAll */ List&lt;Emp&gt; list = new JdbcDemo05().findAll(); for (Emp emp : list) &#123; System.out.println(emp); &#125; //或者 /*for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125;*/ &#125; /** * 定义一个方法findAll，用来查询emp表的数据并将其封装成对象，再将对象装载为集合，返回之。 * 使用自己写的JDBC工具类（JDBCUtils），简化代码 * @return */ public List&lt;Emp&gt; findAll() &#123; ResultSet res = null; Statement stat = null; Connection con = null; List&lt;Emp&gt; list = null; try &#123; //(注册驱动、获取链接)、定义sql、获取执行sql的对象、执行sql con = JDBCUtils.getConnection(); String sql = "select * from emp"; stat = con.createStatement(); res = stat.executeQuery(sql); //遍历结果集、封装emp表的数据为对象、装载集合 Emp emp = null; list = new ArrayList&lt;Emp&gt;(); while (res.next()) &#123; //获取数据 int id = res.getInt("id"); String ename = res.getString("ename"); int job_id = res.getInt("job_id"); int mgr = res.getInt("mgr"); Date joindate = res.getDate("joindate"); double salary = res.getDouble("salary"); double bonus = res.getDouble("bonus"); int dept_id = res.getInt("dept_id"); //创建Emp类的对象，并修改对象的数据值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(res,stat,con); &#125; return list; &#125;&#125; 可以看到使用工具类之后，代码简化了不少，提高了代码复写的效率；并且将 url user password driver 的信息抽取到配置文件中，日后修改 url user password driver 将更加方便，提高了程序的可扩展性。 相关文章推荐&emsp;&emsp;【JDBC练习】使用用户名和密码登录&emsp;&emsp;【JDBC】使用_不使用数据库连接池获取连接对比]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo + Next】侧边栏添加自定义文件夹（如友链）]]></title>
    <url>%2F20190729-friendlink.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;如果你刚刚完成博客的搭建，会发现Next主题的侧边栏默认文件夹很少，不过你可以通过配置主题配置文件_config.yml，增加标签、分类、关于等等文件夹，具体教程可参考官方帮助文档，网上亦有大量教程，这里就不赘述了。 &emsp;&emsp;当你在浏览一些完成度较高的博客时，会发现有的博客的侧边栏会有一些自定义的文件夹，如图1所示，红框中的是Next主题自带的文件夹，蓝框中的是自定义的。 不过，无论是官方帮助文档，亦或是网上的教程，鲜有提及如何创建自定义文件夹。 &emsp;&emsp;通过不断的尝试，笔者终于成功总结出一种解决方法。下面给出在侧边栏新建一个友链文件夹的相关教程。 教程步骤&emsp;&emsp;以MacOS为例，打开终端，开启管理员模式，定位到博客文件夹，执行命令 hexo new page friendlink路径Users/用户名/博客文件夹/source文件夹里就会出现刚刚新建的文件夹friendlink，打开文件friendlink，会发现里面有一个index.md文件，待会再来修改它。 &emsp;&emsp;打开主题配置文件，找到Menu Settings，加入一行代码：friendlink: /friendlink/ || link，如下所示： 12345678menu: home: / || home tags: /tags/ || tags categories: /categories/ || th #search: /search/ || search archives: /archives/ || archive about: /about/ || user friendlink: /friendlink/ || link &emsp;&emsp;打开Users/用户名/博客文件夹/themes/next/languages文件夹里的zh-CN.yml文件，在其中增加一行代码：friendlink: 友链，如下所示： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益 404 friendlink: 友链 &emsp;&emsp;保存文件后执行 hexo cl &amp;&amp; hexo g &amp;&amp; hexo s本地打开博客网站，就能看到侧边栏多了一个友链文件夹，不过这时候点击友链文件夹，里面是一片空白，这时就到了最后一步，修改教程开头提到的index.md文件。 &emsp;&emsp;修改index.md的title，title将显示为网页的标题，然后在文件中写下你想写的内容，格式遵循Markdown，内容将显示在网页当中，我的index.md内容为： 123456789101112131415161718---title: 互换友链date: 2019-07-28 20:23:11---#### 前言&amp;emsp;&amp;emsp;如果您也有自己的个人博客，并且想要互换友链，**可以先在贵站添加我的站点**：[https://www.imcyc.cn](https://www.imcyc.cn)，站名：Morty。**然后再在下方留言,并注明贵站的类型**，审核之后贵站的信息就会被添加到下方列表中～#### 友链列表&amp;emsp;&amp;emsp;以下排名不分先后，欢迎访问(～￣▽￣)～| 站名 | 链接 | 类型 ||:--------------:|:---------------:|:--------------:|| leek | https://bigleek.ml | Java后端 || 菜菜 | https://www.caiyifan.cn | 技术 || Water | https://water1127.github.io | 不详 || Don Lex | https://donlex.cn | 不详 || 赵俊 | http://www.zhaojun.im | Java || 千千 | https://www.dreamwings.cn | 不详 | 保存后执行命令 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d友链页显示效果如图2所示： PS&emsp;&emsp;无论是主题自带的文件夹还是自定义的文件夹，默认都是开启留言功能的（前提是你配置了留言功能），如要关闭留言，加入comments: false即可，如下： 123456---title: 标签date: 2019-07-15 20:55:57type: tagscomments: false--- 参考文献[1] https://www.cnblogs.com/codebook/p/10312965.html[2] https://theme-next.org/docs/theme-settings/ 推荐阅读【Next 7.2.0版权声明大改动】仅需一步！开启内置版权声明(跟繁琐的自定义版权声明说拜拜~) 【Hexo + Next】左侧栏友链一行多个显示 【Hexo + Next 优化之坑】百度、谷歌收录sitemap站点地图]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>友链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo + Next 优化之坑】百度谷歌收录sitemap站点地图]]></title>
    <url>%2F20190721-baidu%2Bgoogle%2Bseo.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;之前陆陆续续写了一些搭建个人博客道路上遇到的坑，现在终于快把博客优化完了，只剩下CDN和SEO两块，今天就讲讲我在SEO中遇到的坑，文章分成两块——百度收录和谷歌收录。 百度收录&emsp;&emsp;按照网上的教程（参考文献[4],[5]），成功部署百度SEO，但是过去了半天，我的sitemap收录依旧是等待状态……，网上有说等几秒就开始收录的，有说等了俩月都没收录的，哎，先放在这里吧，过段时间再来看看。 谷歌收录验证个人网站所有权&emsp;&emsp;首先登陆Google Search Console，在“网址前缀”栏输入你的博客网址，例如我输入的就是https://www.imcyc.ml。 &emsp;&emsp;接着要验证该网址为你所有，有五种验证方式，如下图所示。 &emsp;&emsp;坑点一来了虽然第一种方式谷歌写着“推荐的验证方法”，但是实测效果并不好，至少我用第一种方法没成功，于是我采用第5种方法，虽然在DNSPOD里添加了相关的解析，但是等了许久依旧是显示验证失败，官方说最迟等72小时DNS解析才生效……我想还是算了吧，于是再试试第二种方法，如下图所示，将双引号中的代码复制下来，待会要用。 Hexo已经为我们准备好了 google_site_verification 的环境，在主题配置文件_config.yml中找到 123# Google Webmaster tools verification.# See: https://www.google.com/webmasters google_site_verification: 将刚刚复制的代码粘贴到google_site_verification后面（注意冒号之后空一格），保存后hexo cl &amp;&amp; hexo g &amp;&amp; hexo d，再回到Google Search Console点击验证，即可验证成功。 收录sitemap&emsp;&emsp;谷歌收录操作异常简单，进入站点地图，添加sitemap.xml，提交即可，据说快的话不到一天即可收录成功。（sitemap.xml相关教程参考参考文献[4],[5]） &emsp;&emsp;如果显示“无法获取”，那就将跟你域名相关的所有网址收录进来（包括你的Github仓库地址），每一个地址都添加sitemap。，建议以你的用户名.github.io网址为准，只收录它的sitemap就行了。 &emsp;&emsp;更新：收录你的用户名.github.io.sitemap.xml异常地快，大约十分钟便收录成功。 添加蜘蛛协议和限制爬虫&emsp;&emsp;这一段可参考参考文献[4]。 参考文献[1] http://theme-next.iissnan.com/third-party-services.html#analytics-system[2] https://www.jianshu.com/p/ea6776938bd6[3] https://zhidao.baidu.com/question/518471805846206605.html[4] http://dugblog.coding.me/Hexo/20180625-Hexo-SEO.html[5] https://blog.csdn.net/sinat_37781304/article/details/82729029?tdsourcetag=s_pcqq_aiomsg 推荐阅读【Next 7.2.0版权声明大改动】仅需一步！开启内置版权声明(跟繁琐的自定义版权声明说拜拜~) 【Hexo + Next】左侧栏友链一行多个显示 【Hexo + Next】侧边栏添加自定义文件夹（如友链）]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo + Next】左侧栏友链一行多个显示]]></title>
    <url>%2F20190720-friend-links.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Next主题的友链默认排版是一行一个，如图1所示。 一旦友链数量过多，那么一行一个的页面排版就不怎么美观了，下面笔者教大家如何一行多个地显示友链。 教程步骤&emsp;&emsp;打开你的博客文件夹下的themes/next/layout/_macro/sidebar.swig，sidebar即侧边栏，顾名思义在sidebar.swig文件中我们可以对侧边栏的页面排版进行设置。打开sidebar.swig，搜索关键字blogroll，发现如下代码段： 12345678910111213141516&#123;# Blogroll #&#125;&#123;% if theme.links %&#125; &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.links_layout | default('inline') &#125;&#125;"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;i class="fa fa-fw fa-&#123;&#123; theme.links_icon | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125; &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; &#123;% for blogrollText, blogrollURL in theme.links %&#125; &lt;li class="links-of-blogroll-item"&gt; &#123;&#123; next_url(blogrollURL, blogrollText, &#123;title: blogrollURL&#125;) &#125;&#125; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; 这段代码就是对侧边栏友链的排版定义，其中的： 1234&lt;div class="links-of-blogroll-title"&gt; &lt;i class="fa fa-fw fa-&#123;&#123; theme.links_icon | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125;&lt;/div&gt; 定义的是友链标题和图标，不能缺少；接下来对代码块： 1234567&lt;ul class="links-of-blogroll-list"&gt; &#123;% for blogrollText, blogrollURL in theme.links %&#125; &lt;li class="links-of-blogroll-item"&gt; &#123;&#123; next_url(blogrollURL, blogrollText, &#123;title: blogrollURL&#125;) &#125;&#125; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 进行修改，去掉ul和li，加入span，修改后代码为： 12345&#123;% for blogrollText, blogrollURL in theme.links %&#125; &lt;span class="links-of-blogroll-item"&gt; &#123;&#123; next_url(blogrollURL, blogrollText, &#123;title: blogrollURL&#125;) &#125;&#125; &lt;/span&gt;&#123;% endfor %&#125; &emsp;&emsp;最终修改完成的Blogroll代码块为： 1234567891011121314&#123;# Blogroll #&#125;&#123;% if theme.links %&#125; &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.links_layout | default('inline') &#125;&#125;"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;i class="fa fa-fw fa-&#123;&#123; theme.links_icon | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125; &lt;/div&gt; &#123;% for blogrollText, blogrollURL in theme.links %&#125; &lt;span class="links-of-blogroll-item"&gt; &#123;&#123; next_url(blogrollURL, blogrollText, &#123;title: blogrollURL&#125;) &#125;&#125; &lt;/span&gt; &#123;% endfor %&#125; &lt;/div&gt;&#123;% endif %&#125; 将以上代码替换到themes/next/layout/_macro/sidebar.swig的相应位置，然后hexo cl &amp;&amp; hexo g &amp;&amp; hexo d更新博客，你将惊奇地发现多个友链排在一行当中，如图2所示。 &emsp;&emsp;完结撒花~ 推荐阅读【Next 7.2.0版权声明大改动】仅需一步！开启内置版权声明(跟繁琐的自定义版权声明说拜拜~) 【Hexo + Next】侧边栏添加自定义文件夹（如友链） 【Hexo + Next 优化之坑】百度、谷歌收录sitemap站点地图]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Next 7.2.0 版权声明大改动】仅需一步！开启内置版权声明(跟繁琐的自定义版权声明说拜拜~)]]></title>
    <url>%2F20190720-copyright-liense.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在之前的Next版本中，只需要到主题配置文件_config.yml中将post_copyright下的enable设为true，即可开启版权声明，如图1所示。 &emsp;&emsp;但是在最新的Next7.2.0版本中，官方对版权声明的设置做出了大改动，在主题配置文件_config.yml中已经找不到设置版权声明的post_copyright选项了，于是我在百度搜索：最新Next如何开启版权声明？发现无非两种教程： 老版本Next下的教程，教你设置post_copyright为true，或是修改themes/next/layout/_macro/post-copyright.swig文件，自定义版权声明样式，比如hoxis的教程。 新版本Next下的教程，发布教程的博主显然也发现了新版本Next的post_copyright选项消失了，于是乎他们便“自立门户”，通过新建themes/next/layout/_macro/my-copyright.swig和themes/next/source/css/_common/components/post/my-post-copyright.styl两个文件，再在themes/next/layout/_macro/post.swig和themes/next/source/css/_common/components/post/post.styl两个文件中分别添加相应代码，最后在文章头部添加copyright: true，达到开启版权声明的目的，比如潘高的教程，效果如图2所示。 &emsp;&emsp;于是我按照第二种自定义版权声明的教程亦步亦趋地搞，在折腾的过程中，我惊讶地发现其实官方并没有去掉内置版权声明，只是将它藏得更“深”了（不知道为啥要这么搞，蛋疼…）。下面笔者就教大家如何在Next7.2.0新版本下，开启内置版权声明(许可协议)。 开启内置版权声明步骤 笔者在学习网上教程的时候，在打开themes/next/layout/_macro/post.swig文件后发现，在代码段：123&#123;% if theme.wechat_subscriber.enable and not is_index %&#125; &#123;% include '../_partials/post/wechat-subscriber.swig' %&#125;&#123;% endif %&#125; 下面几行，存在着这么一段代码（具体在357行左右）： 12345&#123;% if theme.creative_commons.license and theme.creative_commons.post and not is_index %&#125; &lt;div&gt; &#123;% include '../_partials/post/post-copyright.swig' with &#123; post: post &#125; %&#125; &lt;/div&gt;&#123;% endif %&#125; 可以看到，中间那行的/_partials/post/post-copyright.swig，正是官方内置的版权声明配置文件！既然存在这个文件，就说明官方并没有抛弃版权声明，那么接下来我们就能顺着蛛丝马迹，一步步找出开启内置版权声明的办法。 打开themes/next/source/css/_common/components/post/post.styl文件，在第58（圣保罗对不起，我不是故意的）行，有一段代码@import &quot;post-copyright&quot; if hexo-config(&#39;creative_commons.post&#39;);。这段代码意思是：在主题配置文件_config.yml中将creative_commons项的post项设为true，就能开启内置版权声明。 打开主题配置文件_config.yml，Ctrl + F搜索找到creative_commons项，如以下代码所示：12345678910# Creative Commons 4.0 International License.# See: https://creativecommons.org/share-your-work/licensing-types-examples# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero# You can set a language value if you prefer a translated version of CC license, e.g. deed.zh# CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.orgcreative_commons: license: by-nc-sa sidebar: true post: true language: 这里就是Next新版本开启内置版权声明的地方，license：设置多种版权声明；sidebar：博客主页左侧栏是否显示版权声明标记；post：是否开启版权声明。开启内置版权声明后的效果如图3所示。 总结&emsp;&emsp;网上一些自定义版权声明的教程，繁琐且麻烦，而且老版本Next下的教程又驴纯不对马嘴。如果你现在用的是新版本的Next，那么只需一步，即可开启版权声明，岂不美哉~ 参考文献[1] https://hoxis.github.io/hexo-next-copyright.html[2] https://theme-next.org/docs/theme-settings/posts[3] http://dugblog.coding.me/Hexo/20180623-hexo-useful-skills.html 推荐阅读【Hexo + Next】侧边栏添加自定义文件夹（如友链） 【Hexo + Next】左侧栏友链一行多个显示 【Hexo + Next 优化之坑】百度、谷歌收录sitemap站点地图]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo博客搭建 • 篇三】一个自定义域名同时绑定Coding(国内访问) + GitHub(国外访问)]]></title>
    <url>%2F20190710-coding-github.html</url>
    <content type="text"><![CDATA[篇一、篇二入口。 前言&emsp;&emsp;在【Hexo博客搭建 • 篇二】中，笔者详细介绍了GitHub仓库绑定自定义域名的方法，但是由于Github服务器的原因，导致访问个人博客不够稳定。本篇将介绍使用一个自定义域名同时绑定Coding + GitHub 的方法，点击imcyc.top，国内用户访问到的是Coding仓库，而国外用户访问到的则是GitHub仓库，堪称完美的解决方案。 hexo托管到coding服务器&emsp;&emsp;将hexo托管到coding服务器上，过程与将hexo托管到github服务器上大同小异。 &emsp;&emsp;1. 在腾讯云开发者平台上注册账号，接着新建一个项目，注意项目地址必须填：你的用户名.coding.me。 &emsp;&emsp;2. 创建完项目后，点击进入项目代码-&gt;Pages服务-&gt;勾选同意-&gt;开启Coding Pages。 &emsp;&emsp;3. 绑定SSH公钥，腾讯云开发者平台的帮助文档就很详细，按这个来就行了。 &emsp;&emsp;4. 回到MacOS，修改自己的blog文件夹下的_config.yml，将其中的一段代码改为如下所示： 12345678# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/Spr-Chan/Spr-Chan.github.io.git coding: https://dev.tencent.com/u/spr_chan/p/spr_chan.coding.me.git branch: master 注意github和coding的url是因人而异的。 &emsp;&emsp;5. 终端定位到/Users/spr_chan/blog并输入sudo su开启超级管理员模式，使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 就能将hexo同时推送到github和coding两个仓库，岂不美哉~ 域名绑定&emsp;&emsp;在【Hexo博客搭建 • 篇二】中，笔者详细介绍了GitHub仓库绑定自定义域名的方法，而Coding仓库绑定自定义域名的方法与前者大同小异。 &emsp;&emsp;1. 进入项目详情页面，找到Pages服务，点击进入设置。 &emsp;&emsp;2. 输入以购买的自定义域名，点击绑定，这时会出现警告信息。 &emsp;&emsp;3. 按照警告信息的要求，我们在域名解析界面添加相应的解析，如下图所示。 &emsp;&emsp;4. 此外再增加四条解析，注意GitHub解析路径选择国外，用以国外用户访问；Coding解析路径选择默认，用以国内用户访问。 &emsp;&emsp;5. 回到Coding，发现域名已经绑定成功，稍等片刻（等待阿里云解析完成），即可使用自定义域名访问个人博客，完结撒花~~]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MacOS</tag>
        <tag>Github</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫实战：汽车导购网站评论爬取（大数据帮你买好车）]]></title>
    <url>%2F20190709-car-website.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;四天入门Python（慕课网地址），三天入门简单爬虫（慕课网地址），八天撸完180行的代码，一路磕磕绊绊，一路的bugbugbug……，索性还是以比较快的速度解决了女票的要求（爬来的数据给女票写小论文用）。直接先码代码贴上，以后有空再对代码进行详解吧…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#爬取爱卡汽车网站所有“纯电动”汽车的“车名”、“价格”、“级别”、“续航”、“电量”,并输出为html#-*- coding: utf-8 -*-from bs4 import BeautifulSoupimport refrom urllib import request#8个电动汽车的总页面的urlfirst_urls = []for i in range(1, 9): first_urls.append('http://newcar.xcar.com.cn/car/0-0-0-0-0-0-0-0-0-0-0-'+str(i)+'-1-0/')#8个总页面下的所有款车的urlnodes_num = []for url in first_urls: response = request.urlopen(url) html_cont = response.read() soup = BeautifulSoup(html_cont.decode('gb2312'),'html.parser') link_nodes = soup.find_all('a', class_="car_search_ps_list_a")#link_nodes是一个list列表 for i in link_nodes: nodes_num.append('http://newcar.xcar.com.cn'+str(i['href']))#构造datas-------------------------------------------------------------datas = []nodes_rev = []#收集有用的url，加工成口碑url存到此列表中count = 0for url_num in nodes_num: count+=1 response_num = request.urlopen(url_num) html_cont_num = response_num.read() soup_num = BeautifulSoup(html_cont_num.decode('gbk'),'html.parser') url_rev = url_num+'review.htm' response_rev = request.urlopen(url_rev) html_cont_rev = response_rev.read() soup_rev = BeautifulSoup(html_cont_rev.decode('gbk'),'html.parser') res_data = &#123;&#125;#dict列表，每轮res_data列表包含13个key（车名、价格......） try: link_node01 = soup_num.find("span", class_="lt_f1").get_text() link_node02 = soup_num.find('div', class_="tt_h1").find("h1").get_text() res_data['车名'] = link_node01+link_node02 link_node03 = soup_num.find('a', class_="com_price_menu").get_text() #print "价格：", link_node03,"万" res_data['价格'] = link_node03 link_node04 = soup_num.find_all('li', class_="w163") res_data['级别'] = link_node04[0].get_text()[4:-1] res_data['续航(km)'] = re.findall("\d+",link_node04[1].get_text())[-1] '''link_node05 = soup_num.find('a', onclick="clicklog(124783);").get_text() #print "电量：", re.findall("\d+",link_node05)[0]+"kWh" res_data['电量'] = re.findall("\d+",link_node05)[0]''' link_node06 = soup_rev.find('div', class_="synthesis").get_text() res_data['综合评分'] = re.findall(r'\d+.\d+', link_node06)[0] link_node07 = soup_rev.find_all('div', class_="bg") res_data['外观'] = re.findall(r'\d+.\d+', link_node07[0].get_text())[0] res_data['内饰'] = re.findall(r'\d+.\d+', link_node07[1].get_text())[0] res_data['空间'] = re.findall(r'\d+.\d+', link_node07[2].get_text())[0] res_data['舒适'] = re.findall(r'\d+.\d+', link_node07[3].get_text())[0] res_data['续航'] = re.findall(r'\d+.\d+', link_node07[4].get_text())[0] res_data['动力'] = re.findall(r'\d+.\d+', link_node07[5].get_text())[0] res_data['操控'] = re.findall(r'\d+.\d+', link_node07[6].get_text())[0] res_data['性价比'] = re.findall(r'\d+.\d+', link_node07[7].get_text())[0] datas.append(res_data) nodes_rev.append(url_rev) print(count) except: print (count, "craw failed")#构造datas_dis----------------------------------------------------------------------------datas_dis = []number = 0for url in nodes_rev:#nodes_rev里存的是有用口碑url url_page = [] try: response_ = request.urlopen(url) html_cont_ = response_.read() soup_ = BeautifulSoup(html_cont_.decode('gbk'),'html.parser') link_nodes = soup_.find_all('a', href="javascript:void(0);", rel="nofollow", class_="page")#取最后一页的页数 last_page = re.findall(r'\d+', link_nodes[-1]['onclick'])[0]#最后一页的页数，是字符型数据，如'4' for i in range(1, int(last_page)+1): url_page.append('http://newcar.xcar.com.cn/auto/index.php?r=reputation/reputation/GetAjaxKbList3&amp;page='+str(i)+'&amp;pserid='+re.findall(r'\d+', url)[0]+'&amp;jh=0&amp;wd=0') except: url_page.append(url) number+=1 datas_02 = [] cout = 0#‘发表时间’、‘购车地点’和‘爱车评价’的插入点索引随url_的变化而变化 try: for url_ in url_page: response = request.urlopen(url_) html_cont = response.read() soup = BeautifulSoup(html_cont.decode('gbk'),'html.parser') link_node_01 = soup.find_all('div', class_="name_lf") for i in link_node_01: res_data = &#123;&#125; res_data['评论人'] = re.findall(r'\A(.+)',i.get_text()[4:])[0]#(.+)和.+都可以，‘\A’ 匹配字符串开头，r'\A(.+)'表示匹配字符串开头的任意字符（空格或换行符前） datas_02.append(res_data) link_node_02 = soup.find_all('div', class_="publish") cout_ = cout for i in link_node_02: datas_02[cout_]['发表时间'] = re.findall(r'\d+-\d+-\d+', i.get_text())[0] cout_+=1 link_node_03 = soup.find_all('div', class_="list_infor") cout_ = cout for i in link_node_03: datas_02[cout_]['购车地点'] = re.findall(r'[[](.*?)[]]', i.get_text().replace('\n','').replace('\n','').replace(' ',''))[0]#先去掉所有空格和换行，再提取[xx市]中的xx市 cout_+=1 cout_ = cout link_node_04 = soup.find_all('div', class_="review_post") for i in link_node_04: datas_02[cout_]['爱车评价'] = re.sub('[\n]+', '\n', i.get_text().strip())#strip()去掉头尾的空格和空行,re.sub('[\n]+', '\n', 'xxx')去掉字符串xxx中多余的空行 cout_+=1 cout+=len(link_node_01) print(number, "craw sucessful") except: print (number, "craw failed") datas_dis.append(datas_02)#datas列表和datas_dis列表相结合--------------------------------------------------------------tot = []#形式为：“tot = [[ , ], [ , ], [ , ],......, [ , ]]”每一个元素都是list列表，每个元素包含一个datas元素和datas_dis元素for i in datas: tot_ = [] tot_.append(i) tot.append(tot_)num_tot = 0for j in datas_dis: tot[num_tot].append(j) num_tot += 1#建立一个文件的输出对象fout，文件名为12121.html, 输出各项数据-----------------------------------#Python默认的编码是：ascii，要输出为utf-8的话，要加encoding = 'utf-8'fout = open('12121.html', 'w', encoding = 'utf-8')fout.write("&lt;html&gt;")fout.write("&lt;body&gt;")fout.write("&lt;table&gt;")for i in tot: for j in i[1]: fout.write("&lt;tr&gt;") fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['车名']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['价格']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['级别']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['续航(km)']) #fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['电量']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['综合评分']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['外观']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['内饰']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['空间']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['舒适']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['续航']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['动力']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['操控']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % i[0]['性价比']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % j['评论人']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % j['发表时间']) fout.write("&lt;td&gt;%s&lt;/td&gt;" % j.get('购车地点')) fout.write("&lt;td&gt;%s&lt;/td&gt;" % j.get('爱车评价')) fout.write("&lt;/tr&gt;")fout.write("&lt;/table&gt;")fout.write("&lt;/body&gt;")fout.write("&lt;/html&gt;")fout.close() 最后输出的是html文件，爬到了800条左右的评论（其中不乏几撮水军），用excel编辑完就是如下效果： &emsp;&emsp;后期的话，如果将网站所有车型的评论都爬取下来，估计得有几十万条评论，分析这些评论数据也会对自己将来购车有所帮助。 PS&emsp;&emsp;相关文章推荐：Python爬虫实战-帮你选购成色完美的二手iPhone]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo博客搭建 • 篇二】GitHub仓库绑定自定义域名]]></title>
    <url>%2F20190708-github-domain.html</url>
    <content type="text"><![CDATA[篇一入口。 前言&emsp;&emsp;使用Hexo+Github完成个人博客的搭建后，我的博客链接就是https://spr-chan.github.io，本文将介绍GitHub仓库绑定自定义域名的方法。 准备域名&emsp;&emsp;1. 购买域名，我已经在freenom免费购买到顶级域名imcyc.top。 &emsp;&emsp;2. 解析域名，解析操作如下图所示。 注意要添加两条解析，记录值是username.github.io。 配置CNAME方法一（不推荐）&emsp;&emsp;在自己的Github仓库新建CNAME，编辑并写入imcyc.top。 接着进入Settings，往下翻到GitHub Pages，发现Custom domain里已经有了imcyc.top，说明这一步操作成功。注意Enforce HTTPS要勾选，这是2018年5月之后Github重磅推出的新功能，让你的个人域名从此不再显示“不安全”。 &emsp;&emsp;方法一不足之处：由于是在仓库根目录下新建的CNAME文件，当我们在MacOS终端使用命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后，CNAME文件就会被冲掉，这是又要再次新建CNAME文件，非常麻烦。 方法二（推荐）&emsp;&emsp;相比较于方法一，方法二在本地blog文件夹里新建CNAME文件再推到Github仓库，这样就避免hexo clean冲掉CNAME文件情况的发生。 &emsp;&emsp;MacOS系统下， 进入Users/spr-chan/blog文件夹下，在其中的source文件夹内新建文件CNAME，增加内容：imcyc.top。再在终端用命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d将博客文件推送到Github仓库，在浏览器地址栏输入imcyc.top或www.imcyc.top，即可访问个人博客，并且不提示连接不安全，完结撒花！ &emsp;&emsp;注：谷歌浏览器输入并前往“imcyc.top”，可能会提示不安全。 PS：增加CSDN博客&emsp;&emsp;跟方法二雷同，在本地Users/spr-chan/blog/source文件夹下新建文件csdn.html，内容为： 12345678&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;&lt;script&gt;function browserRedirect() &#123; window.location.href="http://blog.csdn.net/weixin_43971764";&#125;browserRedirect();&lt;/script&gt;&lt;/html&gt; 推送到Github后，在浏览器地址栏输入imcyc.top/csdn即可跳转至CSDN博客，这样就相当于你的CSDN博客也有了一个专属的个人定制地址。&emsp;&emsp;PS:增加简书或其他博客跳转同理。 篇三入口。 参考文献&emsp;&emsp;[1] https://blog.csdn.net/kong_gu_you_lan/article/details/53788378]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
        <tag>Github</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo博客搭建·篇一】本地博客主题修改后，推到远端服务器的操作细节]]></title>
    <url>%2F20190707-hexo-cl-g-d.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;以MacOS系统为例，在个人博客配置文件夹修改好主题文件后，如何推到远端服务器（github仓库、coding仓库）？网上搜到的答案一般是：&emsp;&emsp;&emsp;&emsp;hexo clean&emsp;//清除缓存文件 (db.json) 和已生成的静态文件 (public)&emsp;&emsp;&emsp;&emsp;hexo g&emsp;&emsp;&emsp;//生成缓存和静态文件&emsp;&emsp;&emsp;&emsp;hexo d&emsp;&emsp;&emsp;//重新部署到服务器hexo操作三连就行了，但是如果我们直接打开终端执行命令hexo clean是会报错的，正确做法是：&emsp;&emsp;1. cd /Users/你的用户文件夹名/你的blog文件夹名//首先定位到博客文件夹&emsp;&emsp;2. sudo su//开启root权限（超级管理员权限）&emsp;&emsp;3. 依次执行命令hexo cl hexo g hexo d，将本地hexo文件推送到远端服务器。回到我们的个人博客网站刷新即可。ps：刷新一次可能没反应，多刷新几次，或等待一会儿再刷新。 &emsp;&emsp;很多时候，我们要对本地hexo文件进行多次修改调整，如果每次调整都需要执行hexo cl hexo g hexo d后再使用浏览器查看个人博客的修改效果，这样的效率是十分低下的，这时我们就可以使用hexo s命令，具体步骤如下： &emsp;&emsp;1. 修改完本地hexo文件后，执行hexo cl hexo g命令，接着执行hexo s，这时我们在浏览器地址栏输入http://localhost:4000，就可以访问我们最新修改后的博客网站（注意这时候本地文件并没有重新部署到服务器端，只是在本地生成的静态网页）。&emsp;&emsp;&emsp;2. 我们可以通过hexo cl hexo g hexo s的命令，在本地对博客进行多次修改配置，并通过网址http://localhost:4000查看博客效果。&emsp;&emsp;&emsp;3. 经过多次修改调整后，最后再执行命令hexo d将本地文件部署到远端服务器，这样的好处是只需要执行一次远端服务器部署，省去了每次修改都需要重新部署查看修改效果的麻烦。 篇二、篇三入口。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
        <tag>MacOS</tag>
        <tag>Github</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【VMware装黑苹果】DiskMakerX制作macOS Mojave 10.14的U盘启动盘]]></title>
    <url>%2F20190705-black-mac-usb.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在色魔张大妈上看到一篇灰常灰常详细的VMware虚拟机装macOS Mojave10.14.x的教程，但是实操中我也遇到了和帖子下面众多网友所遇到的一样的问题，就是在win10平台下使用TransMac制作的 macOS U盘启动盘，VMware无法识别，从而使整个教程进行不下去。 &emsp;&emsp;后来经过一番折腾，发现只有在苹果系统下（无论黑苹果还是白苹果）制作的 macOS U盘启动盘，VMware虚拟机才能识别，WTF？我要是事先就有苹果系统的话，我还折腾什么黑苹果？！ &emsp;&emsp;于是乎就放弃了这位博主的装机思路，转而在网上寻找其它可行的虚拟机装黑苹果的方法。后来我按CSDN博主的帖子，成功安装MAC OS X 10.14 ！甚喜！甚喜！（防止原博主分享的安装包失效，贴一下我的百度云下载地址：防吞去了前缀1n0CtZsOdBbJ94At6zvkOQQ，提取码：mym4）。这个教程的好处是不需要制作U盘启动盘就能虚拟机安装黑苹果，遗憾的地方是装不了macOS Mojave 10.14.x。 &emsp;&emsp;这时突然反应过来，我已经装了个黑苹果，不就满足了“在苹果系统下制作 macOS U盘启动盘”的条件么？于是乎，成功在MAC OS X 10.14黑苹果系统下利用DiskMakerX制作出macOS Mojave10.14.x的U盘启动盘，然后再回到当初的起点：按照什么值得买原创博主的教程，成功在虚拟机上安装macOS Mojave10.14.3的黑苹果系统。 &emsp;&emsp;完结，撒。。。。。。花是不可能滴，接下来就介绍一下本文的主题：如何在macOS系统下使用DiskMakerX制作macOS Mojave10.14.x的U盘启动盘。 工具 macOS 10.14.3 Mojave 官方安装镜像 下载地址：https://www.macxin.com/?s=+macOS+%E6%AD%A3%E5%BC%8F%E7%89%88 DiskMakerX 下载地址：防吞去了前缀1Brv6U42MlNQE_KPpeJUW2w，提取码：svfk Unlocker（这个教程要用到） 下载地址：防吞去了前缀1JnrDszfBd4MZY5brniFwSA ，提取码：yjmi 准备一个容量&gt;=8G的U盘。 教程步骤&emsp;&emsp;1. 将macOS 10.14.3 Mojave.dmg和DiskMaker_X_803.dmg两个文件下载到电脑上，再用鼠标直接把文件拖动到虚拟机黑苹果的桌面上。 &emsp;&emsp;2. 首先双击DiskMaker_X_803.dmg安装之。 &emsp;&emsp;3. 然后双击macOS 10.14.3 Mojave.dmg，会出现一个包含“安装macOS Mojave”的新对话框，将“安装macOS Mojave”直接拖动到桌面。 &emsp;&emsp;4. 拖动到桌面后，将“安装macOS Mojave”这个文件的中文名改成英文名（这样做的目的是让diskmaker能自动发现）。 &emsp;&emsp;5. 将U盘格式化，具体格式化步骤可参见参见这篇教程。 &emsp;&emsp;6. 接下来打开安装好的DiskMakerX软件，软件打开后会自动检测到安装程序，如图一路点击蓝色继续。 &emsp;&emsp;7. 到选择U盘的这一步一定要谨慎，U盘的名字是格式化U盘时起的名字（这里的Mojave是我的U盘的名字，每个人在操作时将有所不同，不可生搬硬套）。 &emsp;&emsp;8. 接下来一路点击下一步继续，然而这个软件有点坑爹的就是，最后一步点完后，它的对话框就消失了，也看不到正在制作U盘启动盘的进度条，害的我还以为系统死机了。实际情况是软件在后台制作U盘启动盘，耐心等待一段时间，会弹出制作完成的对话框。 &emsp;&emsp;9. 最后，拿着你制作好的U盘启动盘，按照文章开头提到的教程，就可以装好macOS Mojave10.14.3的虚拟机了。 &emsp;&emsp;PS：macOS Mojave比macOS X要流畅顺滑一些（仅针对我在虚拟机上的使用体验），贴几张图。]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>虚拟机</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】框架的基本原理下篇：简单的框架测试（使用注解而不是自定义注解）]]></title>
    <url>%2F20190703-shell-test.html</url>
    <content type="text"><![CDATA[上篇及中篇入口。 案例：简单的框架测试&emsp;&emsp;准备一个Calculator类，一个注解，一个测试类。 &emsp;&emsp;Check注解的代码为： 1234567891011package top.imcyc.day07.annotation.demo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)//限用于方法之上public @interface Check &#123;&#125; &emsp;&emsp;Calculator类中写一些正常的方法，写一些会抛出异常的方法，以便测试类测试。类代码为： 1234567891011121314151617181920212223242526272829package top.imcyc.day07.annotation.demo;public class Calculator &#123; @Check public void add() &#123; System.out.println("1+0 =" + (1 + 0)); &#125; @Check public void sub() &#123; String str = null; str.toString();//会出现空指针异常 System.out.println("1-0 =" + (1 - 0)); &#125; @Check public void mul() &#123; System.out.println("1*0 =" + (1 * 0)); &#125; @Check public void div() &#123; System.out.println("1/0 =" + (1 / 0));//会出现数学异常 &#125; public void show() &#123; System.out.println("HelloWorld"); &#125;&#125; &emsp;&emsp;测试类代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142package top.imcyc.day07.annotation.demo;import java.io.*;import java.lang.reflect.Method;public class TestCheck &#123; public static void main(String[] args) throws IOException &#123; //1.创建计算器对象 Calculator cal = new Calculator(); //2.获取字节码文件对象 Class cls = cal.getClass(); //3.获取所有方法 Method[] methods = cls.getMethods(); int num = 0;//出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter("bug.txt")); for (Method method : methods) &#123; if (method.isAnnotationPresent(Check.class)) &#123;//判断方法上有没有指定的注解 try &#123; method.invoke(cal); &#125; catch (Exception e) &#123; //捕获异常，并记录到文件中 num++; bw.write(method.getName() + "方法出现异常"); bw.newLine(); //bw.write("异常的名称："+e.getCause());//java.lang.ArithmeticException: / by zero //bw.write("异常的名称："+e.getCause().getClass().getName());//java.lang.ArithmeticException bw.write("异常的名称：" + e.getCause().getClass().getSimpleName());//ArithmeticException bw.newLine(); bw.write("异常的原因：" + e.getCause().getMessage()); bw.newLine(); bw.write("------------------------------------"); bw.newLine(); &#125; &#125; &#125; bw.write("本次测试一共出现" + num + "次异常"); bw.flush(); bw.close(); &#125;&#125; &emsp;&emsp;程序执行结束后，会生成bug.txt文件，文件内容为： 当测试类执行后，会自动自行被检测的所有方法（加了Check注解的方法），判断方法是否有异常，记录到文件中。可以看到每一个异常都会被详细记录下来。 总结： 为什么要加注解？在类中的成员方法上加注解，主方法执行的时候才能分辨出哪些方法是需要检查的。加注解其实相当于贴“标签”，让主程序来分辨。 大多数时候，我们会使用注解，而不是自定义注解。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】框架的基本原理中篇：注解优化]]></title>
    <url>%2F20190702-shell-note.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在框架的基本原理上篇中，笔者介绍了框架的灵魂：反射机制。使用反射机制，在不改动代码的前提下，只需要改动配置文件中的类名、方法名，就可以创建任意类的对象，可以执行任意方法，这就是框架内部的基本原理。本篇将介绍如何使用注解，将上篇中的配置文件省略并简化代码，达到相同的功能。 &emsp;&emsp;首先，我们新建一个Person类，内容与上篇中相同；新建一个注解接口；新建一个测试类。 &emsp;&emsp;Person类中的代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243package top.imcyc.day07.annotation;public class Person &#123; private String name; private int age; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat() &#123; System.out.println("eat......"); &#125;&#125; &emsp;&emsp;注解接口中的代码为： 12345678910111213package top.imcyc.day07.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String methodName();&#125; &emsp;&emsp;测试类中的代码为： 1234567891011121314151617181920212223package top.imcyc.day07.annotation;import java.lang.reflect.Method;@Pro(className = "top.imcyc.day07.annotation.Person", methodName = "eat")public class reflectTest &#123; public static void main(String[] args) throws Exception &#123; //解析注解(获取注解的属性值) // 1. 获取该类的字节码文件对象 Class&lt;reflectTest&gt; reflectTestClass = reflectTest.class; // 2. 获取顶部的注解的对象 // 其实就是在内存中生成了一个该注解接囗的子类实现对象，子类重写了className和methodName方法，返回的就是"...Person"和"eat"字符串 Pro an = reflectTestClass.getAnnotation(Pro.class); //最终目的是拿到顶部注解里定义的属性值 String s = an.className(); String s1 = an.methodName(); Class cls = Class.forName(s);//获取s代表的类的字节码文件对象 Object obj = cls.newInstance();//获取一个类对象 Method method = cls.getMethod(s1);//获取该类的方法 method.invoke(obj);//执行此方法，参数传入要被执行的方法对应的类对象 &#125;&#125; &emsp;&emsp;可以看到，测试类顶部注解里的属性值就代替了原来配置文件里的内容，省去了设置配置文件，简化了测试代码，同时保持了程序的扩展性。满足在不改动代码的前提下，只需要改动顶部注解的属性值，就可以创建任意类的对象，可以执行任意方法。 &emsp;&emsp;下篇入口。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】框架的基本原理上篇：反射机制]]></title>
    <url>%2F20190702-shell-reflect.html</url>
    <content type="text"><![CDATA[框架：半成品软件。可以在框架的基础上进行软件开发，简化编码；&emsp;&emsp;反射：框架设计的灵魂；将类的各个组成部分封装为其他对象，这就是反射机制。&emsp;&emsp;&emsp;&emsp;好处：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1. 可以在程序运行过程中，操作这些对象；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2. 可以解耦，提高程序的可扩展性。 &emsp;&emsp;这里使用一个简单的案例，介绍一下框架的基本原理。准备工作：新建一个Person类、新建一个pro.properties的配置文件、新建一个测试类。 &emsp;&emsp;Person类中写一个测试方法eat： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package top.imcyc.day07.demo02;import java.io.Serializable;public class Person implements Serializable &#123; private String name; private int age; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat() &#123; System.out.println("eat......"); &#125;&#125; &emsp;&emsp;配置文件中加入Person类名和要执行的方法名： &emsp;&emsp;测试类reflectTest的代码为： 12345678910111213141516171819202122232425262728package top.imcyc.day07.reflect;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Properties;public class reflectTest &#123; public static void main(String[] args) throws Exception &#123; //获取class目录下的配置文件的方式： //1. 获取类reflectTest的字节码文件对象（通过reflectTest.class方法） //2. 获取类reflectTest的字节码文件(对象)对应的类加载器（类加载器：将.class文件中的二进制流加载到内存中） //3. 类加载器寻找配置文件 // 通过类加载器的getResourceAsStream方法，获取到配置文件的字节输入流 //4. 通过Properties的方法load，读取配置文件的字节输入流，转换为一个Map集合。 InputStream is = reflectTest.class.getClassLoader().getResourceAsStream("pro.properties"); Properties pro = new Properties(); pro.load(is);//配置文件转换为Map集合存储到pro中，例如键值对“key:methodName, value:eat” //获取配置文件中的数据 String className = pro.getProperty("className"); String methodName = pro.getProperty("methodName"); Class cls = Class.forName(className);//获取className代表的类的字节码文件对象 Object obj = cls.newInstance();//获取一个类对象 Method method = cls.getMethod(methodName);//获取该类的方法eat method.invoke(obj);//执行此方法，参数传入要被执行的方法对应的类对象 &#125;&#125; &emsp;&emsp;在不改动代码的前提下，只需要改动配置文件中的类名、方法名，就可以创建任意类的对象，可以执行任意方法；这就是框架内部的基本原理！&emsp;&emsp;可以看到使用框架的优点其一：提高程序的可扩展性。 &emsp;&emsp;中篇及下篇入口。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java1.8】实现类、匿名类、内部类、匿名内部类、Lambda表达式以及优化Lambda表达式比较]]></title>
    <url>%2F20190624-lambda-expression.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;梳理一下实现类、匿名类、内部类、匿名内部类、Lambda表达式以及优化Lambda表达式的关系，仅针对初学者。&emsp;&emsp;自定义一个接口MyFunctionInterface，其中有且仅有一个抽象方法（接口中可以有其他非抽象方法内容），代码实现为: 123456789/* 函数式接口：有且只有一个抽象方法的接口，称之为函数式接口； 当然接口中可以包含其他的方法（默认，静态，私有）。 */public interface MyFunctionInterface &#123; public abstract void method(); &#125; 实现类（创建实现类对象）&emsp;&emsp;实现接口MyFunctionInterface，重写其中的抽象方法；新建一个Java文件，实现类代码为：12345678public class MyFunctionInterfaceImpl implements MyFunctionInterface &#123; @Override public void method() &#123; System.out.println("测试成功"); &#125; &#125; &emsp;&emsp;新建一个测试类，代码为： 12345678public class Demo &#123; public static void main(String[] args) &#123; MyFunctionInterface mi = new MyFunctionInterfaceImpl();//多态 mi.method(); &#125;&#125; 匿名类（创建匿名实现类对象） 1234567public class Demo &#123; public static void main(String[] args) &#123; new MyFunctionInterfaceImpl().method(); &#125;&#125; 内部类（不需要创建实现类对象） 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; MyFunctionInterface mi = new MyFunctionInterface() &#123; @Override public void method() &#123; System.out.println("内部类测试成功"); &#125; &#125;; mi.method(); &#125;&#125; 匿名内部类（不需要创建实现类对象） 123456789101112public class Demo &#123; public static void main(String[] args) &#123; new MyFunctionInterface() &#123; @Override public void method() &#123; System.out.println("匿名内部类测试成功"); &#125; &#125;.method(); &#125;&#125; Lambda表达式&emsp;&emsp;因为接口MyFunctionInterface中有且仅有一个抽象方法，所以是函数式接口，可以使用Lambda表达式，代码实现： 12345678910public class Demo &#123; public static void main(String[] args) &#123; MyFunctionInterface mi = () -&gt; &#123; System.out.println("Lambda表达式测试成功"); &#125;; mi.method(); &#125;&#125; 优化Lambda表达式 12345678public class Demo &#123; public static void main(String[] args) &#123; MyFunctionInterface mi = () -&gt; System.out.println("优化Lambda表达式测试成功"); mi.method(); &#125;&#125; &emsp;&emsp;实际上，Lambda表达式常用作方法的参数或方法的返回值。当Lambda表达式作为方法的形参： 12345678910111213141516171819202122232425public class Demo &#123; public static void show(MyFunctionInterface myInter) &#123; myInter.method(); &#125; public static void main(String[] args) &#123; /* //先使用匿名内部类热热身 show(new MyFunctionInterface() &#123; @Override public void method() &#123; System.out.println("匿名内部类测试成功"); &#125; &#125;);//show方法执行myInter.method()之前，method方法已经重写，所以执行成功 */ //Lambda表达式 show(() -&gt; &#123; System.out.println("Lambda表达式测试成功"); &#125;); //优化的Lambda表达式 show(()-&gt;System.out.println("优化的Lambda表达式测试成功")); &#125;&#125; 当Lambda表达式作为方法的返回值（这里使用接口Comparator&lt; String &gt;举例）： 12345678910111213141516171819202122public class Demo &#123; //定义一个方法，方法的返回值类型使用函数式接口Comparator public static Comparator&lt;String&gt; getComparator() &#123;//接口Comparator&lt;&gt;只有一个抽象方法，所以可以使用Lambda表达式 /* //先用匿名内部类热热身 return new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.length()-o1.length();//按字符串降序排序 &#125; &#125;; */ //方法的返回值类型是一个函数式接口，所有我们可以返回一个Lambda表达式(优化后的) return (o1, o2) -&gt; o2.length() - o1.length(); &#125; public static void main(String[] args) &#123; String[] arr = &#123;"cc","bbb","aaaa"&#125;;//首先按字符个数、再按字母进行降序 Arrays.sort(arr,getComparator());//sort(T[] a, Comparator&lt;? super T&gt; c) 根据指定的比较器引发的顺序对指定的对象数组进行排序。 System.out.println(Arrays.toString(arr));//打印结果：[aaaa, bbb, cc] &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】使用文件字节输入/输出流复制文件、使用字节缓冲输入/输出流复制文件的区别]]></title>
    <url>%2F20190619-file-iostream.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;首先我们来对比一下文件字节输入流和字节缓冲输入流的read方法，可以看到两者的read方法的都继承自InputStream类，且read(bytes[ ] b)方法都没有被子类重写，所以代码执行的效率理论上没有区别。 &emsp;&emsp;再来对比文件字节输出流和字节缓冲输出流的write方法，可以看到有所不同：&emsp;&emsp;文件字节输出流的write(bytes[ ] b)是将字节数组中的数据直接写入到此文件输出流，不经过缓冲区；字节缓冲输出流会给文件字节输出流增加一个缓冲区，提高文件字节输出流的写入效率，然后通过flush方法，将缓冲区中的数据刷新到文件中。 &emsp;&emsp;综上所述，使用文件字节输入/输出流复制文件、使用字节缓冲输入/输出流复制文件的区别就在于：&emsp;&emsp;两者在输入上都经过缓冲区（缓冲数组）；但是在输出上，文件字节输出流不经过缓冲区，字节缓冲输出流经过缓冲区。所以理论上，使用字节缓冲输入/输出流进行文件复制的效率要高于使用文件字节输入/输出流。 代码示例&emsp;&emsp;使用文件字节输入/输出流复制一张图片，耗时60毫秒左右。 123456789101112131415public static void main(String[] args) throws IOException &#123; long s = System.currentTimeMillis(); FileInputStream fis = new FileInputStream("C:\\1.jpg"); FileOutputStream fos = new FileOutputStream("D:\\1.jpg"); //一次读取多个字节，写入多个字节的方式（使用数组缓冲） byte[] bytes = new byte[1024];//对于较大的文件，适当调整为1024的整数倍能大幅提高复制效率 int len = 0; while ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes, 0, len);//len保证写入的是字节数组中的有效字节（当前循环中） &#125; fos.close(); fis.close(); long e = System.currentTimeMillis(); System.out.println(e-s); &#125; &emsp;&emsp;使用字节缓冲输入/输出流复制同一张图片，耗时20毫秒左右。 1234567891011121314public static void main(String[] args) throws IOException &#123; long s = System.currentTimeMillis(); BufferedInputStream bis = new BufferedInputStream(new FileInputStream("C:\\1.jpg")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("D:\\1.jpg")); byte[] bytes = new byte[1024]; int len = 0; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes); &#125; bos.close(); bis.close(); long e = System.currentTimeMillis(); System.out.println(e-s); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>输入/输出流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫实战：京东拍拍验机（帮你买到成色完美的二手iPhone）]]></title>
    <url>%2F20190519-PaiPaiYanJi.html</url>
    <content type="text"><![CDATA[网站介绍&amp;使用痛点&emsp;&emsp;如图1所示，京东拍拍二手于近期上线了一个新平台：拍拍验机，顾客可以通过手机京东客户端，在拍拍验机上挑选购买心仪的二手电子产品（目前均为固定品牌的手机，如二手小米8、二手iPhone 7 Plus）。 &emsp;&emsp;在首页，我们可以对手机进行筛选，比如笔者目前倾向于购买二手iPhone 7 Plus 128G 国行，那么就选择“苹果”-&gt;“苹果7P”-&gt;筛选“国行”和“128G”，如图2所示。确定后下拉页面，就都是符合筛选条件的手机了。 &emsp;&emsp;但是，在下拉查看比较手机的过程当中，笔者发现符合筛选条件的手机太多太多了（实测大概400部左右），如果每一个手机都点进去查看对比的话，要把所有手机看一遍，将会消耗大量的时间，而且往往之前看中的手机再回过头来看，已经显示卖出，从而错失良“机”。此外由于手机app端服务器不稳定的原因，在下拉页面浏览的过程中，往往返回上一页面会显示“加载失败”，从而要从头开始重新筛选一遍，再下拉到刚刚浏览的地方，效率十分低下。 &emsp;&emsp;当在浏览过程中，看到心仪的手机，点击进去查看手机的详细介绍，会发现有很多的关键参数，比如电池电量、是否过保以及手机各项详细检测情况，如图3所示。如果我们能针对这些参数进行自主筛选，那么就可以迅速排除掉400多部手机中的绝大多数，“取其精华，去其糟粕”，只留下少量的“精品”进行挑选，这样效率将大大提高。 &emsp;&emsp;但是网站提供的筛选条件少得可怜，只有“价格”、“渠道”、“内存”三个筛选条件，既然如此，我们就要自己动手丰衣足食了。 网站分析&emsp;&emsp;在浏览拍拍验机的主页后，我们发现它一次只会加载20部手机信息，并且加载的方式不是翻页，而是将页面滑动到底部，那么爬取静态网页数据的那一套方法就不能用在现在这种动态网页上（静态网页用Chrome浏览器右键“查看网页源代码”就能看到所有的网页数据，但是动态网页用这种办法是看不到的），这对获取新增的手机数据带来了困难。这里使用Chrome浏览器的“检查”功能解析AJAX动态加载地址，进而找到加载的数据。 &emsp;&emsp;使用Chrome浏览器打开拍拍验机的主页，页面任意处右键，单机“检查”-&gt; Network-&gt; Ctrl + R刷新，每当滑动网页页面到底部时，Network下方会出现新加载的内容，单击 JS，单击左侧的一个_JPx（最好是选最底部的），单击 Headers，可以看到Request URL，如图4所示，后面要用到。注意链接里必须包含order=2_1，因为在实践中发现有些链接包含的是order=4_2，包含order=4_2的链接不是我们所需要的。 &emsp;&emsp;可以发现，每当网页下拉加载新的手机数据的时候，JS里的_JPx就会增加一项，每次下拉刷新得到的新数据就是请求了 1https://bizgw.jd.com/app/inspected/v1/list?pageSize=20&amp;pageNo=1&amp;brand=Apple&amp;model=iphone7%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=128g&amp;callback=__jp7 这个网页的json数据。单击Preview，可以看到json数据的结构，如图5所示。 &emsp;&emsp;其中，我们可以看到新加载的每一个手机的唯一的”commodityId”，后面要用到。将网页一直向下拉，JS中的_JPx就会一直增加，直到网页拉到底。如图6所示，可以看到_JPx增加到_JP22，_JP7到_JP22中就包含了所有的手机的”commodityId”。之后就需要通过Python爬虫将所有的”commodityId”收集起来。 &emsp;&emsp;接着点击进入任意一个手机的详细介绍页面，同样的方法，我们找到商品详情介绍页面的Request URL，详情介绍页面的数据就是请求了 1https://bizgw.jd.com/commodityInspected/view?callback=jQuery34005582774663554724_1558160057557&amp;commodityId=5583330&amp;optSource=3&amp;_=1558160057558 这个网页的json数据，如图7所示。 &emsp;&emsp;在Preview中可以看到json数据的结构，包括保修期、电池电量、验机报告等详细检测数据，甚至能看到网页中看不到的信息，比如“验机中心”，如图8所示。 &emsp;&emsp;通过Python爬虫，根据单个商品json数据的结构中的各种详细参数进行筛选，就能迅速排除掉大量干扰项，达到“取其精华，去其糟粕”的目的了。 项目实施1. 爬取commodityId1.1 失败的爬取思路&emsp;&emsp;通过分析，我们得到_JP7到_JP22包含了所有的手机的”commodityId”。那么就采用常用的requests.get()的方法，通过for循环，将每一个_JPx里的所有”commodityId”爬取出来保存到一个列表中，具体实现代码如下： 12345678910111213141516171819202122232425262728#-*- coding: utf-8 -*-import requestsimport re#定义函数scrapydef scrapy(link): headers = &#123; #User-Agent和Referer的信息在Network-&gt;Headers-&gt;Request Headers 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36', 'Referer':'https://paipai.m.jd.com/direct/?lng=119.954575&amp;lat=31.686691&amp;un_area=12_978_4459_53900&amp;sid=b4d89db2c431e6c9631e9859ecdc099w&amp;_ts=1557926133167&amp;utm_source=iosapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL&amp;ad_od=share&amp;ShareTm=kL%2BfusKf1qywVd%2BwTkAVtGYRXA2gzBQqFj4A0YuGC1teMZhlGn5CDqBdFZvEgw8/2zhgK18/FX3A93HO04B6bPi7qv8sqdX5i/bUuilkbnOp3GDR%2BoHeKPmG1hagOq5B0WaZTCW%2B7KvJdTxfEYpNNpGoA%2BsAMlUKlUnkVPBzD2g=' &#125; r = requests.get(link, headers=headers) return(r.text)#将_jp7到_JP22的所有Request URL保存到一个列表中Req_URL = []for i in range(7, 23): Req_URL.append('https://bizgw.jd.com/app/inspected/v1/list?pageSize=20&amp;pageNo=1&amp;brand=Apple&amp;model=iphone7%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=128g&amp;callback=__jp'+str(i))#将_jp7到_JP22中的的所有commodityId保存到一个列表中all_Id = []for i in Req_URL: m_findall = [] html = "" html = scrapy(i) m_findall = re.findall(r'"commodityId":.&#123;7&#125;', html)#目前网站上机器码暂为7位数 for id in m_findall: all_Id.append(id[-7:]) 通过上述代码，就可以将所有的商品ID储存到列表all_Id当中，但是上述代码有两个问题：&emsp;&emsp;1. 运行代码后，发现每一个_JPx中的商品Id都是相同的，原因尚不清楚；&emsp;&emsp;2. 拍拍验机平台的手机数量是实时刷新的，现在我们看到的是所有商品Id保存在_JP7到_JP22，也许一小时后就变成_JP8到_JP30。 1.2 改进后的巧妙的爬取思路&emsp;&emsp;上述两个问题，第二个问题还好解决，但是第一个问题百思不得其解，涉及比较深入，对于笔者这种学习Python爬虫不足一月的人来说很难解，于是乎转而在Request URL上动心思。原版的Request URL为： 1https://bizgw.jd.com/app/inspected/v1/list?pageSize=20&amp;pageNo=1&amp;brand=Apple&amp;model=iphone7%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=128g&amp;callback=__jp7 笔者将此链接进行一定的删改，发现并不影响request.get()的结果，于是乎将多余的删掉，得到： 1https://bizgw.jd.com/app/inspected/v1/list?pageSize=20&amp;brand=Apple&amp;model=iphone7%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=128g 此时能爬取出20个商品ID。这时发现是不是pageSize=20限制了爬出的ID数量？遂改成pageSize=10000，神奇的事情发生了，400多个商品ID被一次全部爬出！实现代码如下： 123456789101112131415161718192021#-*- coding: utf-8 -*-import reimport requests#定义函数scrapydef scrapy(link): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36', 'Referer':'https://paipai.m.jd.com/direct/?lng=119.954575&amp;lat=31.686691&amp;un_area=12_978_4459_53900&amp;sid=b4d89db2c431e6c9631e9859ecdc099w&amp;_ts=1557926133167&amp;utm_source=iosapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL&amp;ad_od=share&amp;ShareTm=kL%2BfusKf1qywVd%2BwTkAVtGYRXA2gzBQqFj4A0YuGC1teMZhlGn5CDqBdFZvEgw8/2zhgK18/FX3A93HO04B6bPi7qv8sqdX5i/bUuilkbnOp3GDR%2BoHeKPmG1hagOq5B0WaZTCW%2B7KvJdTxfEYpNNpGoA%2BsAMlUKlUnkVPBzD2g=' &#125; r = requests.get(link, headers=headers) return(r.text)url = 'https://bizgw.jd.com/app/inspected/v1/list?pageSize=10000&amp;brand=Apple&amp;model=iphone7%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=128g'html = scrapy(url)m_findall = re.findall(r'"commodityId":.&#123;7&#125;', html)#目前网站上机器码暂为7位数#将所有commodityId保存到一个列表中all_Id = []for i in m_findall: all_Id.append(i[-7:]) &emsp;&emsp;此方法巧妙地跳过了翻页的限制，只需一个修改后的Request URL就可爬出所有商品ID。 2. 增加筛选项&emsp;&emsp;拍拍验机平台的筛选项只有“价格”、“渠道”、“内存”三个筛选条件，但我们可以根据手机的详细介绍页面里的各种参数，利用爬虫任意增加筛选条件，这里我想增加的筛选条件为：电量&gt;=80；全网通；背光异常:无；划痕:无；维修痕迹:无；屏幕碎裂:无；黑点:无；红屏:无；老化发黄:无；亮斑:无；色斑:无；背光异常:无；验机中心非：西安、郑州、河北。这里以一个商品ID为5583330的手机举例，实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#-*- coding: utf-8 -*-import reimport requests#定义函数scrapydef scrapy(link): headers = &#123; #User-Agent和Referer的信息在Network-&gt;Headers-&gt;Request Headers 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36', 'Referer':'https://paipai.m.jd.com/c2c/m/popGoodsDetail?commodityId=5583330&amp;refresh=no&amp;scrollY=0' &#125; r = requests.get(link, headers=headers) return(r.text)link = 'https://paipai.m.jd.com/c2c/m/popGoodsDetail?commodityId=5583330&amp;refresh=no&amp;scrollY=0'html = scrapy(link)m01_findall = re.findall(r'[\u4e00-\u9fa5]+', html)#筛出所有汉字m02_findall = re.findall(r'电池效率","value":"\d&#123;2&#125;', html)#筛出电池电量try: if '立即购买' in m01_findall: ''' 筛选条件： 电量&gt;=80；全网通；背光异常:无；划痕:无；维修痕迹:无；屏幕碎裂:无；黑点:无；红屏:无；老化发黄:无；亮斑:无；色斑:无； 背光异常:无；验机中心不是：西安、郑州、河北 ''' check_bat = (int(m02_findall[0][-2:]) &gt;= 80) check01 = ('全网通' in m01_findall) &amp; (m01_findall[m01_findall.index('背光异常')+1] == '无') check02 = (m01_findall[m01_findall.index('外壳')+2] == '无') &amp; (m01_findall[m01_findall.index('维修痕迹')+1] == '无') check03 = (m01_findall[m01_findall.index('屏幕碎裂')+1] == '无') &amp; (m01_findall[m01_findall.index('黑点')+1] == '无') check04 = (m01_findall[m01_findall.index('红屏')+1] == '无') &amp; (m01_findall[m01_findall.index('老化发黄')+1] == '无') check05 = (m01_findall[m01_findall.index('亮斑')+1] == '无') &amp; (m01_findall[m01_findall.index('色斑')+1] == '无') check06 = (m01_findall[-2][:2] != '西安') &amp; (m01_findall[-2][:2] != '河北') &amp; (m01_findall[-2][:2] != '郑州') if check_bat &amp; check01 &amp; check02 &amp; check03 &amp; check04 &amp; check05 &amp; check06: print("完美") else: print("不完美") else: print("页面异常or已卖出")except: print("不可预知的异常") 3. 筛选所有商品&emsp;&emsp;将“爬取commodityId”的代码和“增加筛选项”的代码结合，通过循环依次筛选每一个商品，将符合筛选条件的商品的链接放到一个列表中，最后依次打印输出，并且自动调用默认浏览器打开通过筛选的商品介绍页面。实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#-*- coding: utf-8 -*-import reimport requestsimport webbrowser#定义函数scrapy01def scrapy01(link): headers = &#123; #User-Agent和Referer的信息在Network-&gt;Headers-&gt;Request Headers 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36', 'Referer':'https://paipai.m.jd.com/direct/?lng=119.954575&amp;lat=31.686691&amp;un_area=12_978_4459_53900&amp;sid=b4d89db2c431e6c9631e9859ecdc099w&amp;_ts=1557926133167&amp;utm_source=iosapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL&amp;ad_od=share&amp;ShareTm=kL%2BfusKf1qywVd%2BwTkAVtGYRXA2gzBQqFj4A0YuGC1teMZhlGn5CDqBdFZvEgw8/2zhgK18/FX3A93HO04B6bPi7qv8sqdX5i/bUuilkbnOp3GDR%2BoHeKPmG1hagOq5B0WaZTCW%2B7KvJdTxfEYpNNpGoA%2BsAMlUKlUnkVPBzD2g=' &#125; r = requests.get(link, headers=headers) return(r.text)#定义函数scrapy02def scrapy02(link): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36', 'Referer':'https://paipai.m.jd.com/c2c/m/popGoodsDetail?commodityId='+link[-7:]+'&amp;refresh=no&amp;scrollY=0' &#125; r = requests.get(link, headers=headers) return(r.text)phone_urls = []#保存每个手机相关的Request URL'''在拍拍验机主页筛选好机型后，右键检查-&gt;Network-&gt;JS-&gt;Ctrl+R刷新-&gt;网页下拉-&gt;选择最靠下的_JPxx-&gt;Headers-&gt;General-&gt;Request URL，将获得的Request URL进行删减和修改pageSize=10000，得到urlNo1'''#iPhone7 Plus 128G 国行urlNo1 = 'https://bizgw.jd.com/app/inspected/v1/list?pageSize=10000&amp;brand=Apple&amp;model=iphone7%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=128g'#iPhone8 Plus 64G 国行#urlNo1 = 'https://bizgw.jd.com/app/inspected/v1/list?pageSize=10000&amp;brand=Apple&amp;model=iphone%208%20plus&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=64g'#iPhone8 64G 国行#urlNo1 = 'https://bizgw.jd.com/app/inspected/v1/list?pageSize=10000&amp;brand=Apple&amp;model=iphone%208&amp;order=2_1&amp;buychannel=%E5%9B%BD%E8%A1%8C&amp;capacity=64g'htmlNo1 = scrapy01(urlNo1)'''在代码a中存在多处“data-commodityid="5614566"”，要筛选出其中的数字，使用正则表达式r'"commodityId":.&#123;7&#125;'。其中，r''的形式是防止字符串内的\转义；"commodityId":表示找到字符串中每一处commodityid；.&#123;7&#125;表示匹配"commodityId":后的7位任意字符（举例：&#123;7&#125;表示只匹配7个字符，&#123;4,7&#125;表示匹配第2位到第4位字符）'''m_findall = re.findall(r'"commodityId":.&#123;7&#125;', htmlNo1)#目前网站上机器码暂为7位数，有待以后更新for i in m_findall: phone_urls.append('https://bizgw.jd.com/commodityInspected/view?commodityId='+i[-7:])#这里没有加“&amp;refresh=no&amp;scrollY=0”，不影响结果fir_urls = []#存放验机中心end_urls = []#存放通过筛选的URLa_ = 1for i in phone_urls: html_01 = "" m01_findall = [] m02_findall = [] html_01 = scrapy02(i) m01_findall = re.findall(r'[\u4e00-\u9fa5]+', html_01)#筛出所有汉字 m02_findall = re.findall(r'电池效率","value":"\d&#123;2&#125;', html_01)#筛出电池电量 #输出通过筛选的url try: if '立即购买' in m01_findall: ''' 筛选条件： 电量&gt;=80；全网通；背光异常:无；划痕:无；维修痕迹:无；屏幕碎裂:无；黑点:无；红屏:无；老化发黄:无；亮斑:无；色斑:无； 背光异常:无；验机中心不是：西安、郑州、河北 ''' check_bat = (int(m02_findall[0][-2:]) &gt;= 80) check01 = ('全网通' in m01_findall) &amp; (m01_findall[m01_findall.index('背光异常')+1] == '无') check02 = (m01_findall[m01_findall.index('外壳')+2] == '无') &amp; (m01_findall[m01_findall.index('维修痕迹')+1] == '无') check03 = (m01_findall[m01_findall.index('屏幕碎裂')+1] == '无') &amp; (m01_findall[m01_findall.index('黑点')+1] == '无') check04 = (m01_findall[m01_findall.index('红屏')+1] == '无') &amp; (m01_findall[m01_findall.index('老化发黄')+1] == '无') check05 = (m01_findall[m01_findall.index('亮斑')+1] == '无') &amp; (m01_findall[m01_findall.index('色斑')+1] == '无') check06 = (m01_findall[-2][:2] != '西安') &amp; (m01_findall[-2][:2] != '河北') &amp; (m01_findall[-2][:2] != '郑州') if check_bat &amp; check01 &amp; check02 &amp; check03 &amp; check04 &amp; check05 &amp; check06: print('No.'+str(a_)+' '+i[-7:]+' '+"完美") fir_urls.append('https://paipai.m.jd.com/c2c/m/popGoodsDetail?commodityId='+i[-7:]+'&amp;refresh=no&amp;scrollY=0'+' '+m01_findall[-2]) end_urls.append('https://paipai.m.jd.com/c2c/m/popGoodsDetail?commodityId='+i[-7:]+'&amp;refresh=no&amp;scrollY=0') else: print('No.'+str(a_)+' '+i[-7:]+' '+"不完美") else: print('No.'+str(a_)+' '+i[-7:]+' '+"页面异常or已卖出") except: print('No.'+str(a_)+' '+i[-7:]+' '+"不可预知的异常") a_ += 1a_02 = 1for i in fir_urls: print('No.'+str(a_02)+' '+i) a_02 += 1#调用默认浏览器自动打开网址for i in end_urls: webbrowser.open(i) &emsp;&emsp;拍拍验机平台上符合“iPhone 7 Plus”、“国行”、“128G”筛选条件的手机有近400部，通过Python爬虫定向筛选，最后输出十多部，耗时1分钟左右，效率提升显著。并且今后可以根据个人喜好不同，自由搭配、增删筛选条件，提升购机效率和精准度。 PS&emsp;&emsp;相关文章推荐：Python爬虫实战-帮你选好车]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】归并排序之一种基于二路归并的归并排序]]></title>
    <url>%2F20190422-GuiBingPaiXu.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;归并排序适用于向量和列表通用；使用的是分而治之的策略；&emsp;&emsp;归：递归。首先将列表一分为二，并不断递归一分为二；&emsp;&emsp;并：合并，将当前的两个子序列（已有序）合并的算法； 下面是通用的归并排序的模板代码： &emsp;&emsp;&emsp;&emsp;template &lt; typename T &gt;&emsp;&emsp;&emsp;&emsp;void Vector :: mergeSort(Rank lo, Rank hi) {&emsp;&emsp;&emsp;&emsp;if（hi - lo&lt;2）return；//一直递归到子序列是单元素，单元素区间自然有序，否则…&emsp;&emsp;&emsp;&emsp;int mi =（lo + hi）&gt;&gt;1；//以中点mi为界&emsp;&emsp;&emsp;&emsp;mergeSort(lo, mi)；//对前子序列递归调用本函数mergeSort，对前半段排序&emsp;&emsp;&emsp;&emsp;mergeSort(mi, hi)；//对后子序列递归调用本函数mergeSort，对后半段排序&emsp;&emsp;&emsp;&emsp;merge(lo, mi, hi)；//归并，将当前的两个子序列（已有序）合并的算法 &emsp;&emsp;由上述代码可知，二路归并排序的计算成本T(n) = 2*T(n/2) + O(n)；其中O(n)为函数merge的计算成本； merge(lo, mi, hi)的基本实现： merge( )的运行时间主要消耗于for循环，共有两个控制变量j和k &emsp;&emsp;初始：j=0，k=0&emsp;&emsp;最终：j=lb，k=lc&emsp;&emsp;亦即：j+k = lb+lc = hi-lo = n &emsp;&emsp;所以for循环共迭代n次，即merge( )总体迭代不过O(n)次，故二路归并排序的计算成本T(n) = 2 * T(n/2) + O(n)成立。通过计算，二路归并算法复杂度为O(n * logn)。计算思路：T(n)到T(1)共有logn层，每层包含一个复杂度为n的算法（merge( )），所以总的时间复杂度为O(n*logn)。 &emsp;&emsp;对于规模为n的向量，归并排序的最优、最坏时间复杂度均为Θ(nlog2n) 。 &emsp;&emsp;注意，若两个待归并子序列不等长甚至相差很悬殊，merge( )的复杂度仍为O(n)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】稍复杂的级数题]]></title>
    <url>%2F20190409-JiShu.html</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;该题求级数的复杂度，简单解析如下图。 &emsp;&emsp;为什么0+0+1+2 * 2+3 * 4+4 * 8+…会是一个几何级数呢？ 几何级数不是等倍数增长吗？ 又是如何推导出O(logn*2^logn)呢？ 问题详解 &emsp;&emsp;可得S与等比数列求和的复杂度同阶，所以S可以当几何级数处理；而几何级数的复杂度与末项同阶且相等，所以S的复杂度为：&emsp;&emsp;O((logn-1) * 2^logn+1) = O(logn * 2^logn)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】模板实参中的参数可以省略的情况分析]]></title>
    <url>%2F20190330-template-parameter.html</url>
    <content type="text"><![CDATA[先来看一道C++二级真题+未来教育解析： &emsp;&emsp;关于在调用模板函数时模板实参的使用，下列表述中正确的是（）。&emsp;&emsp;&emsp;&emsp;A）对于虚拟类型参数所对应的模板实参，如果能从模板函数的实参中获得相同的信息，则都可以省略&emsp;&emsp;&emsp;&emsp;B）对于虚拟类型参数所对应的模板实参，如果它们是参数表中的最后的若干个参数，则都可以省略&emsp;&emsp;&emsp;&emsp;C）对于虚拟类型参数所对应的模板实参，若能够省略则必须省略&emsp;&emsp;&emsp;&emsp;D）对于常规参数所对应的模板实参，任何情况下都不能省略 【未来教育解析】&emsp;&emsp;在调用一个模板函数时，编译系统需要足够的信息来判别每个虚拟类型参数所对应的实际类型，可以从两个不同的渠道获得这样的信息：从模板实参表（用“&lt;&gt;”括起来的参数表）或从模板函数实参表（用“()”括起来的参数表）（这句话表述不准确，应该表述为：从模板函数的形参表（用“()”括起来的参数表）中的形参所对应的实参） 。如果从后者获得的信息已经能够判定其中部分或全部虚拟类型参教所对应的实际参数，而且它们又正好是参数表中最后的若干参数，则模板实参表中的那几个参数可以省略。如果模板实参表中的实参都被省略了，则空表“&lt;&gt;”也可以不要，因此选项D错误。反之，对于某个模板实参，如果从模板函数的实参表中无法获得同样的信息，就不能省略；或者虽然能够获得同样的信息，但在它后面还有其他不能省略的实参，则其自身还是不能省略。本题答案为A选项。 【个人解析】&emsp;&emsp;代码举例： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;template&lt;typename T1, typename T2&gt; //&lt;&gt;里的是虚拟类型参数T1 f(T2 n)&#123; return n*5.6; &#125;int main()&#123; int a = 3; cout &lt;&lt; f&lt;double&gt;(a) &lt;&lt; endl; //1，&lt;&gt;括起来的是模板实参表，()括起来的是模板函数形参表，这里模板实参表省略了int cout &lt;&lt; f&lt;double, int&gt;(a) &lt;&lt; endl; //2 cout &lt;&lt; f&lt;int&gt;(a) &lt;&lt; endl; //3，这里模板实参表省略了int cout &lt;&lt; f&lt;&gt;(a) &lt;&lt; endl; //4，报错 double b = 2.3; cout &lt;&lt; f&lt;double&gt;(b) &lt;&lt; endl; //5，这里模板实参表省略了double cout &lt;&lt; f&lt;int&gt;(b) &lt;&lt; endl; //6，这里模板实参表省略了double cout &lt;&lt; f&lt;&gt;(b) &lt;&lt; endl; //7，报错 return 0;&#125; &emsp;&emsp;a、b分别是模板函数的实参，从实参中获得的信息已经能够判定模板函数的模板实参表中部分或全部虚拟类型参教所对应的实际参数，而且它们又正好是模板实参表中最后的若干参数，则模板实参表中的那几个参数可以省略。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】引用可以指向临时无名对象吗？]]></title>
    <url>%2F20190329-index-unnamed-object.html</url>
    <content type="text"><![CDATA[有如下类定义：class MyClass{public：&emsp;&emsp;MyClass(int d=0): val(d) { }&emsp;&emsp;____ //运算符函数+的声明private：&emsp;&emsp;int val；}；若要使语句序列MyClass x(2), y(4), z；z=7+y；y=x+3；能够正常运行，横线处的声明语句应为（）。A) friend MyClass operator+(MyClass, MyClass);B) friend MyClass operator+(MyClass&amp;, MyClass&amp;);C) friend MyClass operator+(MyClass, MyClass&amp;);D) friend MyClass operator+(MyClass&amp;, MyClass); 【解析】程序中MyClass类给出一个默认构造函数，形参d提整数类型，默认值为0，在成员初始化列表中使用形参d初始化val成员；语句序列中两个表达式：7+y和x+3说明加法运算符函数的两个操作数可以是整型，也可以是MyClass类型，如果是整型的话，需要使用默认构造函数将整数类型隐式转换成临时的MyClass类对象，此时赋给运算符函数时，就不可以使用引用类型了，所以选项B、C、D都是错误的，选项A是正确的。 【个人解析】&emsp;&emsp;为什么将整型隐式转换成临时的类对象之后，就不能将临时对象的引用传入 “friend MyClass operator+(MyClass&amp;, MyClass&amp;)”？ &emsp;&emsp;因为引用的定义是：定义一个引用时，必须同时进行初始化，使它指向一个已经存在的对象。简单地说，引用必须指向一个“有名”的对象。 &emsp;&emsp;而将整型隐式转换成临时的类对象，这个对象是一个临时“无名”对象，没有名字，当然就使用不了引用了。 &emsp;&emsp;由此可以得出结论：C++中无法定义一个引用指向临时无名对象。 &emsp;&emsp;相似的可以联想到，可以使用指针来动态分配内存空间；但是不能使用引用来动态分配内存空间，如：&emsp;&emsp;MyClass *p=new MyClass; //正确&emsp;&emsp;MyClass ＆p=new MyClass; //错误&emsp;&emsp;究其原因，还是因为C++中，不能定义引用指向“无名”对象。 &emsp;&emsp;下面将题目中的代码补充完整，将错误选项D代入执行看看，编译器是否真的会报错： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass(int d = 0) : val(d)&#123;&#125; friend MyClass operator + (MyClass&amp;, MyClass); int Getvalue()&#123; return val; &#125; void Changevalue(int a)&#123; val = a; &#125;private: int val;&#125;;MyClass operator + (MyClass &amp;class1, MyClass class2)&#123; MyClass a; a.Changevalue(class1.Getvalue() + class2.Getvalue()); return a;&#125;int main()&#123; MyClass x(2), y(4), z; z = 7 + y; cout &lt;&lt; z.Getvalue() &lt;&lt; endl; y = x + 3; return 0;&#125; 编译器报错：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 编译器是否隐含生成默认构造函数和默认复制构造函数的4种情况讨论]]></title>
    <url>%2F20190329-default-constructor.html</url>
    <content type="text"><![CDATA[① 类内有自定义构造函数和自定义复制构造函数&emsp;&emsp;根据C++标准定义，如果程序已定义构造函数，默认情况下编译器就不再隐含生成默认构造函数。注意，这里的“构造函数”包括复制构造函数（因为复制构造函数也是构造函数的一种）。 &emsp;&emsp;此时该类一共有2个构造函数：自定义构造函数和自定义复制构造函数。 ② 类内有自定义构造函数，无任何复制构造函数&emsp;&emsp;根据C++标准定义，有自定义构造函数，则无默认构造函数；无自定义复制构造函数，则隐含生成默认复制构造函数。下面使用代码检验： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class A&#123;public: int x; A(int x_=0): x(x_)&#123;&#125;&#125;;int main()&#123; A a; cout &lt;&lt; a.x &lt;&lt; endl; A b(a); //这里调用了默认复制构造函数 cout &lt;&lt; b.x &lt;&lt; endl; return 0;&#125; 代码能正确执行； &emsp;&emsp;类A中没用声明任何复制构造函数，但是可以执行A b(a);说明编译器隐含生成了默认复制构造函数（使用单步跟踪检验，确实如此）。 &emsp;&emsp;此时该类一共有2个构造函数：自定义构造函数和默认复制构造函数。 ③ 类内无任何构造函数，无任何复制构造函数&emsp;&emsp;根据C++标准定义，编译器应该隐含生成默认构造函数和默认复制构造函数。下面用代码检验： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class A&#123;public: int x=0;/*注：可能在早期的C++版本中，类的数据成员不能在声明时进行初始化， 但是在C++11新标准下，类的数据成员可以在声明时进行初始化，但不建议， 因为这样做破坏了类的抽象性)*/&#125;;int main()&#123; A a; //这里调用了默认构造函数 cout &lt;&lt; a.x &lt;&lt; endl; A b(a); //这里调用了默认复制构造函数 cout &lt;&lt; b.x &lt;&lt; endl; return 0;&#125; 代码能正确执行； &emsp;&emsp;注意到，类的数据成员x在声明时同时定义了初始值。可能在早期的C++版本中，类的数据成员不能在声明时进行初始化，但是在C++11新标准下，类的数据成员可以在声明时进行初始化，但不建议，因为这样做破坏了类的抽象性。 &emsp;&emsp;此时该类一共有2个构造函数：默认构造函数和默认复制构造函数。 ⭐④ 类内无任何构造函数，有自定义复制构造函数&emsp;&emsp;（情况④较为特殊，应重点注意）&emsp;&emsp;按照C++标准，编译器应该隐含生成默认构造函数，事实是否如此？下面用代码来检验： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class A&#123;public: int x=0; A(A &amp;a)&#123; &#125;&#125;;int main()&#123; A a; //编译器提示错误，错误信息：类A不存在默认构造函数 cout &lt;&lt; a.x &lt;&lt; endl; A b(a); //这里调用了默认复制构造函数 cout &lt;&lt; b.x &lt;&lt; endl; return 0;&#125; &emsp;&emsp;代码执行错误，编译器并没有隐含生成默认构造函数。 &emsp;&emsp;此时该类一共有1个构造函数：自定义复制构造函数。 PS&emsp;&emsp;C++11新标准中，默认构造函数和默认复制构造函数的一些新特性]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++11新标准】 类的构造函数的个数到底包含不包含默认构造函数？]]></title>
    <url>%2F20190328-all-constructors.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近在用淘宝上买的《未来教育》模拟考试软件刷C++二级的真题，遇到有一条颇有争议的题目，根据C++标准，题目的解析是有问题的，下面来分析一下。 原题：&emsp;&emsp;有如下类定义：&emsp;&emsp;&emsp;&emsp;class MyClass{&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;int value;&emsp;&emsp;&emsp;&emsp;public：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;MyClass(int n)：value(n) { }&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;int getValue() const { return value；}&emsp;&emsp;&emsp;&emsp;};&emsp;&emsp;则类MyClass的构造函数的个数是（）。&emsp;&emsp;A.1个&emsp;&emsp;B.2个&emsp;&emsp;C.3个&emsp;&emsp;D.4个&emsp;&emsp;【未来教育解析】本题考查类的默认构造函数和自定义的构造函数。本题中MyClass(int n)：value(n){ }为自定义的构造函数，加上默认构造函数，一共有2个构造函数。故本题答案为B选项。 &emsp;&emsp;【个人解析】根据C++的标准，如果程序已定义构造函数，默认情况下编译器就不再隐含生成默认构造函数。如果此时依然希望编译器隐含生成默认构造函数，可以使用“=default”。如：&emsp;&emsp;class MyClass{&emsp;&emsp;&emsp;&emsp;int value;&emsp;&emsp;public：&emsp;&emsp;&emsp;&emsp;MyClass() = default;&emsp;&emsp;&emsp;&emsp;MyClass(int n)：value(n) { }&emsp;&emsp;};&emsp;&emsp;此时类MyClass一共有三个构造函数：自定义的构造函数和编译器隐含生成的默认构造函数和默认复制构造函数。 &emsp;&emsp;未来教育给的答案虽然是正确的，但是解析是错误的。原题的正确解析应该是：有两个构造函数，自定义构造函数和默认复制构造函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】顺序队列、循环队列、带链队列”队空队满时，队头队尾指针的情况分析]]></title>
    <url>%2F20190327-queue.html</url>
    <content type="text"><![CDATA[顺序队列的三种状态 队空&emsp;qu.front == qu.rear&emsp;如图1所示，当顺序队列队空时，队头指针front和队尾指针rear相同；注意front和rear不是真正的指针，而是int型变量，代表元素下标。注：随着出队入队的操作，当出现队空状态时，队头队尾指针不一定指向第一个元素。 队满&emsp;qu.front == 0；qu.rear == max+1 一般状态&emsp;qu.front == 0；qu.rear == n；//此时队内元素总数为n-1 循环队列的三种状态 队空&emsp;qu.front == qu.rear&emsp;如图所示，当循环队列队空时，队头指针front和队尾指针rear相同。 队满&emsp;qu.front == qu.rear&emsp;如图所示，当循环队列队满时，队头指针front和队尾指针rear相同。 一般状态&emsp;qu.front == 0；qu.rear == n; //队内元素总数为n-1 带链队列的三种状态 一般状态&emsp;在带链队列中，front和rear是真正的指针，指向节点的指针。 队空&emsp;lqu-&gt;front == NULL 或 lqu-&gt;rear == NULL 即当带链队列为空时，队头指针front和队尾指针rear相同（都为空）。 队内只有一个元素&emsp;lqu-&gt;front == lqu-&gt;rear&emsp;与队空的情况相似，当带链队列只有一个元素时，队头指针front和队尾指针rear相同。 队满&emsp;带链队列不存在队满的情况。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【c++】常对象、常数据成员、常成员函数总结]]></title>
    <url>%2F20190325-const-obj-data-func.html</url>
    <content type="text"><![CDATA[常数据成员&emsp;◆ 常数据成员必须进行初始化，并且不能被更新。&emsp;◆ 常数据成员不能在声明时赋初始值（普通数据成员也是），常数据成员必须在构造函数初始化列表进行初始化；普通数据成员在初始化列表和函数体中初始化均可。&emsp;◆ PS：类的成员对象若要传入参数初始化，则必须在构造函数初始化列表进行；（成员对象：当一个类的成员是另一个类的对象时，这个对象就叫成员对象。） 常对象&emsp;◆ ⭐常对象可以调用常成员函数，不能调用非const成员函数；非const对象，可以调用普通成员函数和常成员函数。&emsp;◆ 常对象的成员函数不一定都是常成员函数；同样的常对象的数据成员不一定都是常数据成员。&emsp;◆ 常对象一旦初始化，常对象的数据成员便不允许修改，而不是说常对象的数据成员都是常数据成员。&emsp;◆ PS：定义常对象有两种方法，1. Point const a; 2. const Point a;（同样的，定义变量或指针时，const放前放后意义一样，如：1. const double a; double const a; 2. const int *p; int const *p; 但是定义指针常量时，只能用 int * const p;） 常成员函数&emsp;◆ 常成员函数不更新对象的数据成员。&emsp;◆ 常成员函数的const关键字可以被用于参与对重载函数的区分。&emsp;◆ ⭐通常非const成员函数需要定义一个const版本的重载函数，以方便定义常对象后调用常成员函数。&emsp;&emsp;◈ 如果常对象调用的常成员函数返回的是指向当前对象的指针（或返回的是当前对象），那么此常成员函数的声明的返回类型要加const，例如： &emsp;&emsp;&emsp;&emsp;◊ 成员函数返回指向当前对象的指针&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const *Point fun1();&emsp;&emsp;&emsp;&emsp;//非const成员函数的类内声明；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const *Point fun1() const;&emsp;//习惯上要再声明一个常成员函数作重载函数，注意到此函数声明有两个const； &emsp;&emsp;&emsp;&emsp;◊ 成员函数返回指向当前对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const Point fun1();&emsp;&emsp;&emsp;&emsp;//非const成员函数的类内声明；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const Point fun1() const;&emsp;//习惯上要再声明一个常成员函数作重载函数，注意到此函数声明有两个const； &emsp;&emsp;&emsp;&emsp;◊ ⭐注意，如果一个类中声明以下4个重载函数：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;① Point fun1();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;② const Point fun1();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;③ Point fun1() const;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;④ const Point fun1() const;&emsp;&emsp;&emsp;&emsp; 【解析】①和②是冲突的，因为无法区分仅按返回类型区分的重载函数；③和④是冲突的，也是因为无法区分仅按返回类型区分的重载函数。&emsp;&emsp;&emsp;&emsp;&emsp;所以正确的重载函数搭配有3种： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;◊ ①和③搭配：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Point fun1();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//函数返回非const对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Point fun1() const;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//函数返回非const对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[解析]适用于定义常对象后调用常成员函数，常成员函数返回类型是非const的Point类对象。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;◊ ①和④搭配（这里把返回类型改为指针，因为常用）：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Point *fun1() {return this; };&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//函数返回指向本对象的指针&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const Point *fun1() const { return this; };//函数返回指向本常对象的指针，第一个const说明返回的是指向常对象的指针，第二个const说明此函数是常函数 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[解析]适用于定义常对象后调用常成员函数，常成员函数返回类型是常Point类对象（如return *this;）。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;◊ ②和④搭配：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const Point fun1();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//函数返回常对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const Point fun1() const;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;//函数返回常对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[解析]适用于定义常对象后调用常成员函数，常成员函数返回类型是常Point类对象。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;◊ ②和③搭配：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;const Point fun1();&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Point fun1() const;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[解析]虽然搭配合法，但是似乎不存在这种搭配。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++二级难题图解】对二维数组数组名作指针的考察]]></title>
    <url>%2F20190324-2D-Array-Pointer.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;若已知 int a[3][7];，则用指针表示数组a中的元素时，下列表示中错误的是（）。 &emsp;&emsp;A）* (a+1)[5]&emsp;&emsp;B）* (* a+3)&emsp;&emsp;C）* (* (a+1))&emsp;&emsp;D）* (&amp;a[0][0]+2) 【解析】 &emsp;&emsp;(a+1)相当于指向a[1]的指针；&emsp;&emsp;(a+1)[5]相当于(a+6)相当于指向a[6]的指针；&emsp;&emsp;* (a+1)[5]相当于* ((a+1)[5])相当于a[6]。 &emsp;&emsp;A选项等价于a[6]（a[6]是指向a[6][0]的指针），但a[6]不存在，故A选项错误。 注意到： [ ]运算符的优先级大于*运算符； (a+1)[5]等价于(a+6)等价于&amp;a[6]。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】一图搞懂：指针常量、指向常量的指针、常变量定义时是否需要初始化]]></title>
    <url>%2F20190323-Pointer-Constant.html</url>
    <content type="text"><![CDATA[纵向对比：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>常变量</tag>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三张图搞透第一范式（1NF）、第二范式（2NF）和第三范式（3NF）的区别]]></title>
    <url>%2F20190320-1NF-2NF-3NF.html</url>
    <content type="text"><![CDATA[第一范式（1NF）&emsp;&emsp;列1唯一确定列2, 列3, 列4, ...，即列2, 列3, 列4, ...不能再分裂出其它列。 &emsp;&emsp;假设有关系模式列1: 订单名; 列2: 商品。一个订单下可以有多个商品，即列2: 商品可以分裂成商品A, 商品B, 商品C, ...，所以列1: 订单名; 列2: 商品这样的关系模式不符合第一范式。 第二范式（2NF）&emsp;&emsp;满足2NF的前提是必须满足1NF。此外，关系模式需要包含两部分内容，一是必须有一个（及以上）主键；二是没有包含在主键中的列必须全部依赖于全部主键，而不能只依赖于主键的一部分而不依赖全部主键。 &emsp;&emsp;定义听起来有点绕，不慌，直接看图，只有全部的非主键列依赖于全部主键，才满足第二范式。 &emsp;&emsp;假设一顾客在超市买了三瓶肥宅快乐水，那么存在关系模式主键1: 商品名称; 列1: 购买数量; 列2: 商品ID; 列3: 购买日期。购买数量和商品ID只依赖于商品名称，购买日期不依赖于商品名称，所以该关系模式不满足第二范式。 第三范式（3NF）&emsp;&emsp;满足3NF的前提是必须满足2NF。另外关系模式的非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列m既依赖于全部主键，又依赖于非主键列n的情况。 &emsp;&emsp;定义听起来还是有点绕，不慌，直接看图，只要非主键内部存在传递依赖，就不满足第三范式。 &emsp;&emsp;假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式。 示例&emsp;&emsp;设有课程关系模式如下：R(C#, Cn, T, Ta)（其中C#为课程号，Cn为课程名，T为教师名，Ta为教师地址），并且假定不同的课程号可以有相同的课程名，每门课程只有一位任课教师，但每名教师可以有多门课程。关系R范式最高达到（）。 A）1NFB）2NFC）3NFD）BCNF 【正确答案】B 【解析】 &emsp;&emsp;一个“课程号”确定一个“课程名”，确定一个“教师名”，确定一个“教师地址”，所以符合第一范式； &emsp;&emsp;“课程号”是无重复的，所以“课程号”是主键，“课程名”、“教师名”、“教师地址”均是可重复的，所以它们都是非主键列并完全依赖于主键“课程号”，所以符合第二范式； &emsp;&emsp;非主键列“教师地址”传递依赖于非主键列“教师名”，所以不符合第三范式，故选B。]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】指向动态分配的指针数组的指针]]></title>
    <url>%2F20190317-pointer-array.html</url>
    <content type="text"><![CDATA[首先介绍指向数组的指针： &emsp;&emsp;char *p = new char; 定义指向动态分配的字符变量的指针；&emsp;&emsp;char *p = new char[3]; 定义指向动态分配的一维字符数组的指针，p指向数组首个元素的地址，即(p+1)为数组第二个元素的地址；&emsp;&emsp;char (*p)[3] = new char[2][3]; 定义指向动态分配的二维字符数组（三行）的指针，p指向数组首行的地址，即(p+1)为数组第二行的地址；&emsp;&emsp;char (*p)[9][8] = new char[7][9][8]; 定义指向动态分配的三维字符数组的指针（7个9列8行的二维数组），p指向首个二维数组的地址，即(p+1)为第二个二维数组的地址；&emsp;&emsp;同样的，char数据类型可换成其他数据类型，比如Point类类型，例：&emsp;&emsp;Point *p = new Point[2]; 定义指向动态分配的一维Point类对象数组的指针。 再介绍指针数组：&emsp;&emsp;这里只举例一维指针数组：Point *p[2]; 定义一个Point类对象的数组，数组里的两个元素都是指向Point类对象的指针（p[0], p[1]）。 最后，指向动态指针数组的指针： &emsp;&emsp;int *p = new int *[10]; //错误&emsp;&emsp;int **p = new int *[10]; //正确 &emsp;&emsp;new int *[10]表示动态生成一个包含10个int型指针的数组，要定义指向指针数组的指针p，那么p也就是指向指针数组首元素，而指针数组首元素是一个int型指针，所以p就是指向int型指针的指针，即指向指针的指针。要定义指向指针的指针，就要使用T **p的格式。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】一图搞懂“从栈底往栈顶压、从栈顶往栈底压”两种情况]]></title>
    <url>%2F20190317-stack-top-bottom.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;设栈的存储空间为S(1:m)，表示栈内存储m个元素。 &emsp;&emsp;通常情况，栈都是从栈底往栈顶压，初始状态栈顶指针top=0（栈空）。当top=m+1，栈满；当top=n（n&lt;=m），栈内有n个元素。 &emsp;&emsp;当从栈顶往栈底压时，初始状态栈顶指针top=m+1（栈空）。当top=0，栈满；当top=n（n&lt;=m+1），栈内有(m-top+1)个元素。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS小技巧 证件照蓝底/红底换白底（非抠图，抠图头发边缘处理效果差）]]></title>
    <url>%2F20190311-identification-photo.html</url>
    <content type="text"><![CDATA[打开PhotoShop 打开图片 在页面顶端选择“图像”-&gt;“调整”-&gt;“替换颜色” 将鼠标移动到证件照背景蓝色任意位置单击一下，红框中的“颜色”就会变成鼠标刚刚选中的颜色，再将“颜色容差”调整到最大值200。 点击“结果”，在弹出的“拾色器”中将R、G、B均改为255，再确定、确定。 将“明度”调整到100。 最后的成品，边缘效果（尤其是头发边缘）比抠人像换背景颜色好得多。 如果把“明度”调为100后，人脸颜色有变化，就参考知乎链接修改。不过最新版本的PS软件更加智能化，基本上不会出现人脸颜色变化的情况。 红底的操作方法与蓝底是雷同的，如果有其它颜色的背景色，按照文中方法同样是可以操作的。]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】在函数对象参数只能是一元谓词的情况下，如何使用二元谓词]]></title>
    <url>%2F20190310-unitary-binary-predicate.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;C++STL库中的find_if的第三个参数只能是一元谓词（即只能传给一元谓词一个参数），但是在设计算法的过程中，需要第三个参数是二元谓词（即需要传给谓词函数两个参数），那么这时候就可以使用bind1st/bind2nd函数适配器，将二元谓词的某一个参数绑定为一个常数，这样二元谓词就变成了一元谓词，find_if只需要传给二元谓词一个参数就也能正常使用。 &emsp;&emsp;例如： 1234567891011121314151617181920212223//找到数组中第一个大于40的元素#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int intArr[] = &#123; 30, 90, 10, 40, 70, 50, 20, 80 &#125;; const int N = sizeof(intArr) / sizeof(int); vector&lt;int&gt; a(intArr, intArr + N); vector&lt;int&gt;::iterator p = find_if(a.begin(), a.end(), bind2nd(greater&lt;int&gt;(), 40)); /*greater是二元谓词（函数对象有两个参数，只返回真或假），但是find_if的第三个参数只能是一元谓词， 为了将greater变为一元谓词，就需要使用find2nd函数适配器将greater的第二个参数绑定为常数40， 当find_if函数在遍历vector元素的迭代器时，就只需要传给greater一个参数就行了（即将迭代器所指向的 元素的值传给greater的第一个参数与第二个已绑定的参数40作比较，返回比较大小的结果为真或假）。*/ //注，greater有两个参数x、y，返回的是x&gt;y为真或假 if (p == a.end()) cout &lt;&lt; "no element greater than 40" &lt;&lt; endl; else cout &lt;&lt; "first element greater than 40 is: " &lt;&lt; *p &lt;&lt; endl; return 0;&#125; &emsp;&emsp;将二元谓词greater的第二个参数绑定为40，这样find_if只需要给greater传一个参数与40作比较就可以了（传入greater的参数就是遍历vector元素的迭代器所指向的元素的值）。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】for循环语句使用前置++和后置++有何区别？]]></title>
    <url>%2F20190308-preposition%2B%2Bpostposition%2B%2B.html</url>
    <content type="text"><![CDATA[在for循环中几乎没有区别，因为它的执行顺序for(partA; partB; partC) 首先执行partA 然后每次循环之前执行partB 每次循环之后执行partC 唯一的区别就是在某些情况下效率不同 对于基本数据类型，前置/后置++执行效率应该一样 对于对于用户自定义类型重载的++如最常见的iterator则++i效率要高一些 当然也不是绝对的 如果你用的是支持随机存储的容器如vector,string等，++iterator应该和iterator++是没有区别的，因为通常迭代器简单实现为普通指针 但是，如list,map,set等容器，iterator就没有这么简单了，++iterator效率高于iterator++,因为省了一个临时对象 参考文献&emsp;&emsp;[1] https://bbs.csdn.net/topics/30253911]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】动态数组类模板中，为什么重载了指针转换运算符T *之后，还要重载下标运算符[ ]？]]></title>
    <url>%2F20190305-DynamicArray-Override.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;重置指针转换运算符函数的声明，（注意函数没有指定返回值的类型，这是语法的要求，跟其他重载函数不一样的地方，要注意）： 123operator T *();operator const T *() const;/*后置const是为了让常对象能调用这个成员函数(常对象只能调用常成员函数，不能调用普通成员函数)； “const T*”表示，通过对象名创建动态数组后，通过对象名不能改变数组*/ &emsp;&emsp;假设动态数组类模板Array，假设类外函数read，形参int *p表示定义指向动态数组的指针p： 1234void read(int *p, int n)&#123; for(int i = 0; i &lt; n; i++) cin&gt;&gt;p[i];&#125; &emsp;&emsp;调用read函数并传入Array类型指针时，因为read函数只接受int类型指针，所以会自动搜索从Array型指针到int型指针的转换方式，如果能搜索到，就执行转换，把转换后的指针交给read函数，搜索不到，编译器就会报错。 &emsp;&emsp;光重载指针转换运算符还不够，要想对象名能像数组名一样使用下标，还要重载下标运算符： 12T &amp; operator [] (int i);const T &amp; operator [] (int i) const; 为什么重载了指针转换运算符之后，还要重载下标运算符？可以这样理解： &emsp;&emsp;虽然重载了指针转换运算符，但是其作用只是为了能把对象名a当类内动态数组名list一样，传入类外函数的参数表作形实结合（实参是对象名，形参是T型指针）； &emsp;&emsp;如果接着在main函数写a[i]，编译器是不会把这里的a当作数组名list的，所以仅仅是写a[i]是无法调用数组元素的(编译器不认这种代码)，只有重载了下标运算符“[ ]”，编译器才会把a[i]当成list[i]； 简单的说， &emsp;&emsp;重载指针运算符，作用仅限于把“a”转换成“list”；重载下标运算符，作用仅限于把“a[i]”转换成“list[i]”； &emsp;&emsp;也就是说，不要以为把对象名a转换成了指向动态数组的指针之后，就能像使用“数组名+下标”一样使用“对象名+下标”来调用数组元素，这样的操作是错误的，编译器是不认的。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【win10小技巧】解决windows 10睡眠后再唤醒，就会自动关机并重启的问题]]></title>
    <url>%2F20190304-sleep-to-restart.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;不管是左下角的睡眠选项，还是直接合上笔记本的盖子，计算机都应该是进入了睡眠状态。之后再按键盘上的任意键，计算机都应该会直接唤醒，唤醒后的计算机状态跟睡眠前的计算机状态是一毛一样的。 &emsp;&emsp;但是我的笔记本就是这么的不听话（一开始我以为，是因为我自己重装的win10系统的问题），在睡眠之后，如果我再唤醒电脑，很明显感觉到，笔记本键盘灯亮了、硬盘开始转了，似乎像是马上就要唤醒了！ &emsp;&emsp;但是！下一刹那！键盘灯全熄，硬盘也停转，接着就是正常的不紧不慢的重启。。。。。。 &emsp;&emsp;在网上查了各种帖子，看了无数的经验，试了几乎所有的方法，无非是设备管理器禁止节约电源啦、电池管理关闭快速启动啦等等等等，但是全部都毫无卵用。 &emsp;&emsp;就在我尝试了无数的方法之后，就快完全丧失信心的时候，我突然想，是不是我一开始的思路就是错误的？然后我仔细地把我的电脑的情况审视了一遍，发现原来我被网上的思路给带歪了！ &emsp;&emsp;网上的解决方法，都是从win10系统的角度去解决问题的，但是从计算机系统（非windows这种操作系统）的角度来讲，睡眠再唤醒这件事，其实跟win10系统是无关的。因为当你的电脑睡眠之后，掌控你电脑“主权”的并不是win10系统，而是计算机嵌入在主板上的最底层的操作系统（俗称BIOS），所以想要解决这个问题，就算把windows10改成花儿也无济于事。我们要修改的，应该是BIOS的状态。 &emsp;&emsp;有了这个思路，我只尝试了一次，就成功了。。。。。。 &emsp;&emsp;解决的方法简单到令人发指，就八个字——重置BIOS设置。 &emsp;&emsp;以我的笔记本戴尔Dell 燃7000 Pro（Dell Inspiron 7580）为例， 第二次更新：&emsp;&emsp;上面提到的方法虽然管用，但是后来发现，重置BIOS设置一段时间后（大概几天），问题依然还是会出现，这时又得重置BIOS设置，然后反反复复出现同样的问题，治标不治本！&emsp;&emsp;最近我发现一个一劳永逸的方法，能彻底解决“睡眠后再唤醒，就会自动关机并重启”的问题，不过最近我在准备秋招，诸事繁杂，等有空我会再来更新的~~]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】为什么要使用继承？为什么要使用动态绑定？为什么要使用虚函数？]]></title>
    <url>%2F20190303-extends-implements.html</url>
    <content type="text"><![CDATA[继承和动态绑定对程序的编写有两方面的影响：&emsp;&emsp;使用继承，我们可以更容易地定义与其他类相似但不完全相同的新类；&emsp;&emsp;使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。 &emsp;&emsp;通过使用动态绑定，我们能用同一段代码分别处理基类和派生类们的对象。在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。动态绑定，又称运行时的绑定，顾名思义，即在程序运行时选择调用哪个版本(对象)的虚函数。 &emsp;&emsp;有虚函数，程序就可以在运行阶段做决定到底选择哪个版本的虚函数；没有虚函数，程序就会在编译阶段静态绑定(不做选择)。那个为什么要大费周章地使用动态绑定、使用虚函数呢？这样是为了能使用同一段代码（一个函数，函数的形参有基类的引用或指针），用来处理很多的类(基类和其派生类们)的对象。 &emsp;&emsp;设想一下，如果没有虚函数，每个基类的派生类都定义自己独立的net_price(返回书籍的实际销售价格的成员函数)，那么就不可能设计同一段代码(同一个函数)来调用所有的类的对象的net_price(类外函数的形参是设成基类的引用(或指针)呢？还是哪个派生类的引用(或指针)呢？) &emsp;&emsp;所以通过继承和动态绑定(使用虚函数)这两大法宝，可以实现以统一的方式，自如地调用各种类的对象，使我们能够编写具有特定类型行为但又独立于类型的程序。这种统一的美学，是必须要追求的。 &emsp;&emsp;注：在C++中，动态绑定只作用于虚函数，并且需要通过指针或引用调用。 我们能将基类的指针或引用绑定到派生类对象中的基类部分上。 &emsp;&emsp;Quote item; &emsp;&emsp;&emsp;&emsp;&nbsp;//基类对象&emsp;&emsp;Bulk_Quote bulk;&emsp;&emsp;//派生类对象&emsp;&emsp;Quote *p = &item;&emsp;//p指向基类对象&emsp;&emsp;p = &bulk; &emsp;&emsp;&emsp;&emsp;&nbsp;//p指向派生类中的基类部分（派生类的对象的地址，可以赋值给指向基类的指针）&emsp;&emsp;Quote &amp;r = bulk;&emsp;&nbsp;//定义一个基类对象的引用r，绑定到派生类中的基类部分（用派生类的对象，可以初始化基类的引用） 这种转换通常称为派生类到基类的类型转换。换种说法，我们可以把派生类的对象当基类的对象来使用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 【常/非常变量地址赋给常/非常指针】暨【常/非常变量值赋给常/非常变量】8种情况对错分析]]></title>
    <url>%2F20190224-constant-variable-pointer.html</url>
    <content type="text"><![CDATA[常/非常变量地址赋给常/非常指针123456正确： A. int a, *p = &amp;a; B. int a; const int *p = &amp;a; C. const int a; const int *p = &amp;a;错误： D. const int a; int *p = &amp;a; 总结：&emsp;&emsp;对于把变量地址赋值给指针的情况，普通变量地址可以赋给普通指针/常指针，常变量地址可以赋给常指针、不能赋给普通指针。 常/非常变量值赋给常/非常变量123456正确： A. int a, b; b = a; B. const int a; int b; b = a;错误： C. int a; const int b; b = a; D. const int a; const int b; b = a; 总结：&emsp;&emsp;对于把变量值赋给变量的情况，普通变量值可以赋给普通变量，不能赋给常变量；常变量值可以赋给普通变量，不能赋给常变量。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>常变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【win10实用小技巧】谷歌浏览器书签固定到开始菜单屏幕（磁贴）当中]]></title>
    <url>%2F20190221-chrome-start-menu.html</url>
    <content type="text"><![CDATA[将目标书签拖动到桌面，在桌面上形成该书签的快捷方式。 将桌面的书签快捷方式复制到C盘如下目标文件夹下（C:\ProgramData\Microsoft\Windows\Start Menu\Programs） 打开开始菜单，就能看到书签了，右键固定到开始屏幕。 结果完美。 参考文献&emsp;&emsp;[1] https://blog.csdn.net/luofl1992/article/details/52263669]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】“复制构造”比“先构造，后赋值”更加高效]]></title>
    <url>%2F20190218-copy-constructor.html</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;Student为表示学生的类且未重载赋值操作符，则下述程序中有调用复制构造函数的是： 12345678//程序 aint main() &#123; Student t1; Student t2(t1); //1 Student t3 = t1; //2 return 0;&#125; 123456789//程序 bint main() &#123; Student t1; Student t2(t1); //1 Student t3; t3 = t1; //2 return 0;&#125; 解答&emsp;&emsp;程序a中的1和2都带调用了复制构造函数；而程序b中只有1调用了复制构造函数，2没有调用。&emsp;&emsp;Student t3 = t1的意思可以表达为：利用对象t1“初始化”对象t3；&emsp;&emsp;t3 = t1的意思可以表达为：将对象t1“赋值”给对象t3。 利用单步跟踪的方法，可以发现：&emsp;&emsp;对象t1“初始化”对象t3时，编译器调用了复制构造函数，但没有调用构造函数；&emsp;&emsp;先定义t3,再把对象t1“赋值”给对象t3时，编译器调用了构造函数，但没有调用复制构造函数； 结论&emsp;&emsp;由此可见，复制构造函数可以一步解决：“初始化”一个新对象并给其“赋值”的功能，比先构造，后赋值更加高效一点（针对使用已有对象初始化新对象的情况）。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>复制构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python】列表中元素和其索引的绑定和迭代]]></title>
    <url>%2F20190119-list-element-index.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 提示：考虑使用zip()函数和range()函数 使用range()函数 123L=zip([1,2,3,4], ['Adam', 'Lisa', 'Bart', 'Paul'] )for i in range(0,4): print L[i][0],'-',L[i][1] 不使用range()函数 123L=zip([1,2,3,4], ['Adam', 'Lisa', 'Bart', 'Paul'] )for i,j in L: print i,'-',j zip()函数的另一种使用方法 123L=['Adam', 'Lisa', 'Bart', 'Paul']for i,j in zip(range(1,len(L)+1),L): print i,'-',j 使用enumerate()函数 123L=['Adam', 'Lisa', 'Bart', 'Paul']for i,j in enumerate(L): print i+1,'-',j 提示：enumerate（）函数 &emsp;&emsp;使用 enumerate() 函数，我们可以在for循环中同时绑定元素的索引和元素的名字。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]变成了类似： [(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)]&emsp;&emsp;实际上，通过enumerate()函数，列表中的每一个元素都变成了一个含有两个元素的tuple列表。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python】list列表和set列表之间的相互删除和补充]]></title>
    <url>%2F20190118-list-set.html</url>
    <content type="text"><![CDATA[First&emsp;&emsp;list列表中的元素跟set列表中有相同的，把list列表中的相应元素删掉。 解决方法&emsp;&emsp;首先，采用如下代码，输出为[‘Lisa’, ‘Bart’]。 12345678s = set(['Adam', 'Lisa', 'Paul'])L = ['Adam', 'Lisa', 'Bart', 'Paul']x=-1for m in L: x+=1 if m in s: L.pop(x)print L &emsp;&emsp;尝试改进代码后，输出为[‘Lisa’, ‘Paul’]； 123456789s = set(['Adam', 'Lisa', 'Paul'])L = ['Adam', 'Lisa', 'Bart', 'Paul']x=-1for m in L: x+=1 if m in s: L.pop(x) x-=1print L &emsp;&emsp;很奇怪’Adam’删掉了，’Lisa’并没有被删掉，于是增加set和list的元素之后再做尝试，输出结果为[‘Lisa’, ‘cyc’, ‘Paul’]。 123456789s = set(['Adam', 'Lisa', 'Paul' ,'cyc'])L = ['Adam', 'Lisa', 'Bart', 'cyc', 'Paul']x=-1for m in L: x+=1 if m in s: L.pop(x) x-=1print L &emsp;&emsp;于是发现规律：当list列表中的一个元素被删掉，那么紧接着这个被删掉的元素的后面的元素(‘Lisa’和’cyc’)就不会被删掉，不管’Lisa’和’cyc’有没有跟set里的元素重复。所以看上去就好像’Lisa’和’cyc’被跳过了。 &emsp;&emsp;于是我们可以这样理解：当编译器执行完L.pop(0)时，原来的L[0]被删除了，后面的元素全部左移一位(‘Lisa’变为L[0]，’Bart’变为L[1])，然后编译器回到for m in L:，这时的m指的是L[1]，那么L[0]的’Lisa’就被跳过了，同理’cyc’也是。 &emsp;&emsp;所以最好创建一个L的副本LL，只改动LL的内容，L不变，如下： 1234567891011s = set(['Adam', 'Lisa', 'Paul'])L = ['Adam', 'Lisa', 'Bart', 'Paul']LL = ['Adam', 'Lisa', 'Bart', 'Paul']x=-1for m in L: x+=1 if m in s: LL.pop(x) x-=1L=LLprint L &emsp;&emsp;结果输出[&#39;Bart&#39;]。 Second&emsp;&emsp;list列表中的元素跟set列表中有相同的，则把set列表中的相应元素删掉;list中的有而set中没有的元素，则添加到set中。 解决方法12345678s = set(['Adam', 'Lisa', 'Paul'])L = ['Adam', 'Lisa', 'Bart', 'Paul']for n in L: if n in s: s.remove(n) else: s.add(n)print s &emsp;&emsp;输出结果为set([&#39;Bart&#39;])。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Set</tag>
        <tag>Python</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++面向对象】类的静态数据成员（static修饰）和常数据成员（const修饰）的初始化]]></title>
    <url>%2F20190112-static-const-datamember.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;类的常数据成员（由const修饰）必须在构造函数的初始化列表里被初始化，不能在构造函数的函数体中被赋值； &emsp;&emsp;又因为构造函数可以在类内或类外实现，所以表面上看，常数据成员可在类内初始化，也可在类外初始化。如： 常数据成员在类外初始化 12345678class A&#123; public: A(int i);//构造函数 private: const int a; &#125;A::A(int i):a(i)&#123; &#125; 常数据成员在类内初始化 123456class A&#123; public: A(int i):a(i)&#123; &#125;;//构造函数 private: const int a; &#125; 而静态数据成员（由static修饰）只能在类内声明，类外初始化，如： 12345类内：private: static int b;类外：int "类名"::b = "初始值"； &emsp;&emsp;那么有些童鞋就有疑问了，如果一个类的数据成员既是常数据成员，又是静态数据成员，那么该怎么定义和初始化呢？静态常数据成员（由static const修饰）的初始化方法如下： 12345类内：private: static const int b;类外：const int "类名"::b = "初始值"； &emsp;&emsp;可以看到，初始化的方法和静态数据成员是一样的，所以我觉得static比const高一等级。在static面前，const降到跟int一级，从类外初始化的前缀“const int”也能窥探一二。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
